<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>yongqi.foo&#x2F;blog</title>
    <link rel="self" type="application/atom+xml" href="https://yongqi.foo/blog/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://yongqi.foo/blog"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-11-18T00:00:00+00:00</updated>
    <id>https://yongqi.foo/blog/atom.xml</id>
    <entry xml:lang="en">
        <title>Motivations Behind Fixed-Point-Oriented Programming</title>
        <published>2024-11-18T00:00:00+00:00</published>
        <updated>2024-11-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yongqi.foo/blog/posts/flix/"/>
        <id>https://yongqi.foo/blog/posts/flix/</id>
        
        <content type="html" xml:base="https://yongqi.foo/blog/posts/flix/">&lt;h1 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;Introduction&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In this post I shall summarize the key ideas behind the Flix programming language [&lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;flix&#x2F;#flix&quot;&gt;Madsen et al; 2016&lt;&#x2F;a&gt;] and how it is differentiated from Datalog. None of what I write here is original work.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation&quot; aria-label=&quot;Anchor link for: motivation&quot;&gt;Motivation&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;The motivation behind the development of Flix is static analysis, which performs an over-approximation of program behaviour. The idea behind most static analyses is that they compute an abstract state that over-approximates all possible states that a program can reach. Typically, the abstract states form a &lt;strong&gt;lattice&lt;&#x2F;strong&gt;, and computing the &quot;best&quot; (least) approximation can be done by starting with the $\bot$ abstract state, and iteratively applying a monotone abstract transfer function on $\bot$ until the &lt;strong&gt;least fixed point&lt;&#x2F;strong&gt; is reached.&lt;&#x2F;p&gt;
&lt;p&gt;One of the challenges when working with static analyzers is that the computation of fixed points imposes many mutual dependencies, and worklist algorithms that do so are complex. This causes implementations of such algorithms to be&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;brittle; changes to the specification or the problem domain requires significant rewrites&#x2F;restructuring of the implementation&lt;&#x2F;li&gt;
&lt;li&gt;complex; implementations of worklist algorithms that compute fixed points are difficult to understand and does not concisely convey the &quot;spirit&quot; of the algorithm&lt;&#x2F;li&gt;
&lt;li&gt;difficult to optimize; due to the above, implementing optimizations to worklist algorithms, both on an engineering level and an algorithm level, is nontrivial&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As such, some analysis designers use Datalog, a logic programming language that supports the concise expression of fixed point problems by merely specifying relations and rules. In addition, Datalog solvers implement optimizations such as index selection, query planning and parallel execution.&lt;&#x2F;p&gt;
&lt;p&gt;Loosely, Datalog operates on &lt;strong&gt;facts&lt;&#x2F;strong&gt; and &lt;strong&gt;rules&lt;&#x2F;strong&gt;. Facts are essentially predicates that are assumed to be true, for example, &quot;Alice is a parent of Bob&quot;. This can be written as &lt;code&gt;parent(alice, bob)&lt;&#x2F;code&gt;. Rules are ways to infer new facts from existing relations. For example, we can write &lt;code&gt;ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).&lt;&#x2F;code&gt; which says that &lt;code&gt;X&lt;&#x2F;code&gt; is an ancestor of &lt;code&gt;Z&lt;&#x2F;code&gt; if &lt;code&gt;X&lt;&#x2F;code&gt; is the parent of some &lt;code&gt;Y&lt;&#x2F;code&gt; such that &lt;code&gt;Y&lt;&#x2F;code&gt; is an ancestor of &lt;code&gt;Z&lt;&#x2F;code&gt;. After defining facts and rules, users can perform &lt;strong&gt;queries&lt;&#x2F;strong&gt; from the Datalog solver, which uses the facts and rules to infer more facts to answer the query.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lattices-and-kleene-s-fixed-point-theorem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lattices-and-kleene-s-fixed-point-theorem&quot; aria-label=&quot;Anchor link for: lattices-and-kleene-s-fixed-point-theorem&quot;&gt;Lattices and Kleene&#x27;s Fixed-Point Theorem&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;As a quick aside, before we talk about Datalog and Flix, we shall describe lattices and fixed points, which will give more context behind how Datalog, Flix, and static analyses in general, work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;partial-orders&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#partial-orders&quot; aria-label=&quot;Anchor link for: partial-orders&quot;&gt;Partial Orders&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Partial Order).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;partial order&lt;&#x2F;strong&gt; $\sqsubseteq$ on a set $P$ is a reflexive, transitive and antisymmetric relation on $P$:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Reflexive: $\forall x\in P.~x \sqsubseteq x$&lt;&#x2F;li&gt;
&lt;li&gt;Transitive: $\forall x, y, z \in P.~x \sqsubseteq y \land y \sqsubseteq z \to x \sqsubseteq z$&lt;&#x2F;li&gt;
&lt;li&gt;Antisymmetric: $\forall x,y \in P. x \sqsubseteq y \land y \sqsubseteq x \to x = y$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$(P,\sqsubseteq)$ is a &lt;strong&gt;partially ordered set&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Partially ordered sets can be enriched to form &lt;strong&gt;lattices&lt;&#x2F;strong&gt;. There are many variants of lattices, each with some additional features, but for us we shall use the broad term &quot;lattice&quot; to describe partially ordered sets with all the features that we want.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lattices&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lattices&quot; aria-label=&quot;Anchor link for: lattices&quot;&gt;Lattices&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Lattice).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;lattice&lt;&#x2F;strong&gt; $(L,\sqsubseteq,\sqcup,\sqcap)$ is such that:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$(L, \sqsubseteq)$ is a partially ordered set&lt;&#x2F;li&gt;
&lt;li&gt;Every pair of elements $a,b\in L$ has a &lt;strong&gt;least upper bound&lt;&#x2F;strong&gt; $a \sqcup b \in L$, which is an element $x$ such that $a\sqsubseteq x$ and $b \sqsubseteq x$ and $\forall y \in L.~ a\sqsubseteq y \land b\sqsubseteq y \to x \sqsubseteq y$. $\sqcup$ is also known as a &lt;strong&gt;binary join&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Every pair of elements $a,b\in L$ has a &lt;strong&gt;greatest lower bound&lt;&#x2F;strong&gt; $a \sqcap b \in L$, which is an element $x$ such that $x\sqsubseteq a$ and $x \sqsubseteq b$ and $\forall y \in L.~ y\sqsubseteq a \land y\sqsubseteq b \to y \sqsubseteq x$. $\sqcap$ is also known as a &lt;strong&gt;binary meet&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Complete Lattice).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;complete lattice&lt;&#x2F;strong&gt; $(L,\sqsubseteq,\sqcup,\sqcap,\top,\bot)$ is a lattice with greatest and least elements $\top$ and $\bot$ such that every subset of $L$ has an &lt;strong&gt;infimum&lt;&#x2F;strong&gt; (meet of all elements in subset) and a &lt;strong&gt;supremum&lt;&#x2F;strong&gt; (join of all elements in subset):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For every subset $Y \subseteq L$, $\inf Y$ is an element $x$ in $L$ such that $\forall y \in Y.~x\sqsubseteq y$ and $\forall z\in L.\ (\forall y\in Y.\ z \sqsubseteq y)\to z \sqsubseteq x$.&lt;&#x2F;li&gt;
&lt;li&gt;For every subset $Y \subseteq L$, $\sup Y$ is an element $x$ in $L$ such that $\forall y \in Y.~y\sqsubseteq x$ and $\forall z\in L.\ (\forall y\in Y.\ y \sqsubseteq z)\to x \sqsubseteq z$.&lt;&#x2F;li&gt;
&lt;li&gt;$\top = \sup L = \inf \emptyset$&lt;&#x2F;li&gt;
&lt;li&gt;$\bot = \inf L = \sup\emptyset$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;The powerset of any set, when ordered by inclusion, is a complete lattice. In other words, given any set $S$, $(\mathcal{P}(S), \subseteq, \cup,\cap,S,\emptyset)$ is a complete lattice. Every subset $Y$ of $\mathcal{P}(S)$ has an infimum given by $\inf Y = \bigcap Y$ and supremum given by $\sup Y = \bigcup Y$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Any nonempty finite lattice is complete. The infimum of any subset $Y = \{s_1,\dots,s_n\}$ of the lattice is $s_1\sqcap s_2\sqcap\dots\sqcap s_n$. Argue dually for the supremum.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Nonexample.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$(\mathbb{R}, \leq, \max,\min)$ is not a complete lattice. Although $\max$ and $\min$ are binary joins, the maximum and minimum elements do not always exist in a subset of $\mathbb{R}$ (they do not even exist in $\mathbb{R}$).&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;In static analysis, lattice elements are usually the possible properties of some point of a program. For example, in data-flow analysis, we attempt to determine the possible values of a variable at a certain program point. Take the following example C program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;lt;stdio.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;        x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07171;&quot;&gt;printf&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;%d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4cbf99;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; x)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, the set of all possible values &lt;code&gt;x&lt;&#x2F;code&gt; can have is $\{0, 1, 2\}$ since these are the only constants in the program. To best approximate the possible values of &lt;code&gt;x&lt;&#x2F;code&gt; at each program point, we will assign to each program point a subset of $\{0, 1, 2\}$ which denotes the best approximation of the possible values that &lt;code&gt;x&lt;&#x2F;code&gt; can have at that point. To start off, &lt;code&gt;x&lt;&#x2F;code&gt; is given an initial set of possible values $\emptyset$ at every program point. Next, in the first assignment statement, &lt;code&gt;x&lt;&#x2F;code&gt; is assigned &lt;code&gt;0&lt;&#x2F;code&gt;, so at that program point, the possible values &lt;code&gt;x&lt;&#x2F;code&gt; can have now becomes $\{0\} \cup \emptyset = \{0\}$. Similarly, in each branch of the &lt;code&gt;if&lt;&#x2F;code&gt; statement, the possible values &lt;code&gt;x&lt;&#x2F;code&gt; can have are $\{1\}$ and $\{2\}$ respectively. Finally, at the &lt;code&gt;printf&lt;&#x2F;code&gt; statement, &lt;code&gt;x&lt;&#x2F;code&gt; could have inherited the possible values from either branch, in which case we take the union of the possible values from both branches, concluding that at that program point, the possible values of &lt;code&gt;x&lt;&#x2F;code&gt; is $\{1, 2\}$. Recall from above that these subsets of $\{0, 1, 2\}$ are elements of the powerset lattice of $\{0, 1, 2\}$, and taking unions are lattice joins, and the initial possible values is $\emptyset$, which is $\bot$.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chains&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#chains&quot; aria-label=&quot;Anchor link for: chains&quot;&gt;Chains&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Before we talk about being able to determine the &quot;best approximation&quot; of program properties, we shall first describe some properties of lattices that allow us to compute this best approximation.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Chain).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A subset $Y\subseteq L$ of a partially ordered set $(L, \sqsubseteq)$ is a &lt;strong&gt;chain&lt;&#x2F;strong&gt; if it is totally ordered by $\sqsubseteq$, i.e. it is such that&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall y_1,y_2 \in Y.\ y_1 \sqsubseteq y_2 \lor y_2 \sqsubseteq y_1
$$&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Ascending and Descending Chains).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A sequence of elements $l_1,l_2,\dots$ is an &lt;strong&gt;ascending chain&lt;&#x2F;strong&gt; if&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall n,m \in \mathbb{N}.\ n \leq m \to l_n \sqsubseteq l_m
$$&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, a sequence of elements $l_1,l_2,\dots$ is a &lt;strong&gt;descending chain&lt;&#x2F;strong&gt; if&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall n,m \in \mathbb{N}.\ n \leq m \to l_m \sqsubseteq l_n
$$&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;From the definitions above, it is clear that both ascending and descending chains are also chains (to see this, put every element in the ascending&#x2F;descending chain in a set; clearly, $\sqsubseteq$ is now a total order on that set).&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Eventually Stabilize).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A sequence of elements $l_1,l_2,\dots$ &lt;strong&gt;eventually stabilizes&lt;&#x2F;strong&gt; if and only if:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\exists c \in \mathbb{N}.\ \forall n \in \mathbb{N}.\ n \geq c \to l_n = l_c
$$&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Chain Conditions).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A partially ordered set $(L, \sqsubseteq)$ has &lt;strong&gt;finite height&lt;&#x2F;strong&gt; if and only if all chains are finite.&lt;&#x2F;p&gt;
&lt;p&gt;A partially ordered set $(L,\sqsubseteq)$ satisfies the &lt;strong&gt;ascending chain condition&lt;&#x2F;strong&gt; if and only if all ascending chains eventually stabilize. Similarly, it satisfies the &lt;strong&gt;descending chain condition&lt;&#x2F;strong&gt; if and only if all descending chains eventually stabilize.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;(Complete) lattices that meet the ascending&#x2F;descending chain condition(s) or have finite height are particularly interesting for us because it gives us a procedure for computing the &quot;best&quot; approximations of program properties in static analyses, and in fact, in many other domains such as graph theory and parsing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;functions-and-fixed-points&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#functions-and-fixed-points&quot; aria-label=&quot;Anchor link for: functions-and-fixed-points&quot;&gt;Functions and Fixed Points&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Fixed Point).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$x \in A$ is a &lt;strong&gt;fixed point&lt;&#x2F;strong&gt; of a function $f: A \to A$ if $x = f(x)$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Monotone).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose $(L, \sqsubseteq_L)$ and $(M, \sqsubseteq_M)$ are partially ordered sets. A function $f: L \to M$ is &lt;strong&gt;monotone&lt;&#x2F;strong&gt; if&lt;&#x2F;p&gt;
&lt;p&gt;$$
\forall x,y\in L.\ x \sqsubseteq_L y \to f(x) \sqsubseteq_M f(y)
$$&lt;&#x2F;p&gt;
&lt;p&gt;In other words, $f$ is monotone if it is order preserving.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Typically, the way static analyses improve the approximation of program properties is with monotone transfer functions, that give more information about the properties of a program point incrementally and monotonically. In a sense, it does not &quot;subtract&quot; old information, and only adds new information to it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kleene-s-fixed-point-theorem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kleene-s-fixed-point-theorem&quot; aria-label=&quot;Anchor link for: kleene-s-fixed-point-theorem&quot;&gt;Kleene&#x27;s Fixed-Point Theorem&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We now finally describe Kleene&#x27;s Fixed-Point Theorem, which shows that given certain conditions, we can compute the best approximation of a program property iteratively using a monotone function.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Kleene&#x27;s Fixed-Point Theorem.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have a partially ordered set $(L,\sqsubseteq)$ with a least element $\bot$ that meets the ascending chain condition. Then, given any monotone function $f: L \to L$, the &lt;strong&gt;least fixed point&lt;&#x2F;strong&gt; of $f$ (denoted $lfp(f)$) exists and is obtained by&lt;&#x2F;p&gt;
&lt;p&gt;$$
lfp(f) = f^n(\bot)
$$&lt;&#x2F;p&gt;
&lt;p&gt;for some $n \in \mathbb{N}$ and such that $f^n(\bot) = f^{n + 1}(\bot)$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. First we show that $f^n(\bot)$ is indeed a fixed point of $f$. By definition, $\bot \sqsubseteq f(\bot)$. Because $f$ is monotone, $f(\bot) \sqsubseteq f(f(\bot))$, i.e. $\bot \sqsubseteq f(\bot) \sqsubseteq f(f(\bot))$. We can thus show with induction that the sequence $\bot, f(\bot), f(f(\bot)),\dots$ is an ascending chain. Because $(L,\sqsubseteq)$ meets the ascending chain condition, this ascending chain eventually stabilizes, hence there will be some $n$ such that $f^n(\bot) = f^{m}(\bot)$ for all $m \geq n$. As such, since $f^n(\bot) = f(f^n(\bot))$, $f^n(\bot)$ is a fixed point.&lt;&#x2F;p&gt;
&lt;p&gt;Now we show that $f^n(\bot)$ is the &lt;strong&gt;least&lt;&#x2F;strong&gt; fixed point, i.e. if $x$ is another fixed point of $f$ then $f^n(\bot) \sqsubseteq x$. Firstly, $\bot \sqsubseteq x$ by definition. Next, because $f$ is monotone and $x$ is a fixed point, we also know that for all $i \in \mathbb{N}$, $f^i(\bot) \sqsubseteq x \to f^{i + 1}(\bot) \sqsubseteq f(x) = x$. Therefore, by induction, $f^n(\bot) \sqsubseteq x$ for all $n$, which means that $f^n(\bot)$ is indeed the least fixed point of $f$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Kleene&#x27;s Fixed-Point Theorem thus shows us that as long as we have a partially ordered set whose elements describe program properties, that meets the ascending chain condition, and has a bottom element, and a monotone function $f$ that improves our approximations of program properties, to get the best approximation, we start from $\bot$ and repeatedly apply $f$ until a fixed point arises.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, dually, the greatest fixed point of a monotone function can also be obtained from a partially ordered set that meets the descending chain condition and has a greatest element $\top$.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;connections-to-complete-lattices&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#connections-to-complete-lattices&quot; aria-label=&quot;Anchor link for: connections-to-complete-lattices&quot;&gt;Connections to Complete Lattices&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The following theorem shows the connections between partially ordered sets that have least fixed points and complete lattices.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A partially ordered set $(L,\sqsubseteq)$ is a complete lattice that meets the ascending chain condition if and only if it has a least element $\bot$ and binary joins $\sqcup$ and meets the ascending chain condition.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. The forward implication is shown by definition so we prove the converse. To do so, we shall prove the following lemma to simplify our main proof.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Lemma.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Every subset $Y$ of a partially ordered set $(L, \sqsubseteq)$ has a supremum if and only if $(L,\sqsubseteq)$ is a complete lattice.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. The backward implication is shown by definition so we prove the forward implication only. Let $Y \subseteq L$. We then have an element $x$ in $L$ that is the supremum of all elements of $L$ less than all elements in $Y$:&lt;&#x2F;p&gt;
&lt;p&gt;$$
x = \sup \{l \in L\ |\ \forall l&#x27; \in Y.\ l \sqsubseteq l&#x27;\}
$$&lt;&#x2F;p&gt;
&lt;p&gt;$x$ is in fact the infimum of $Y$ since the set $\{l \in L\ |\ \forall l&#x27; \in Y.\ l \sqsubseteq l&#x27;\}$ is the set of all elements in $L$ that are less than (or equal to) all the elements of $Y$ (these are all lower bounds) and its supremum is necessarily the greatest among them.&lt;&#x2F;p&gt;
&lt;p&gt;As such, since every subset of $L$ has infima and suprema, $L$ itself has an infimum $\bot$ and a supremum $\top$ and is thus a complete lattice.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Returning to our main proof obligation, using our freshly proven lemma it suffices to show that all subsets $Y$ of $L$ have a supremum. If $Y$ is empty, then clearly $\sup Y = \bot$ so this case is proven.&lt;&#x2F;p&gt;
&lt;p&gt;Now suppose $Y$ is nonempty and finite, i.e. $Y = \{y_1, \dots, y_n\}$ for $n \geq 1$. $\sup Y$ is clearly $y_1\sqcup y_2\sqcup\dots\sqcup y_n$.&lt;&#x2F;p&gt;
&lt;p&gt;The last case is more tricky. Suppose $Y$ is infinite. We shall construct the following sequence $l_0, l_1,\dots$ inductively:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Let $l_0$ be an arbitrary element $y_0$.&lt;&#x2F;li&gt;
&lt;li&gt;Given $l_n$ let $l_{n + 1}$ be
&lt;ul&gt;
&lt;li&gt;$l_n$ if $\forall y \in Y.\ y \sqsubseteq l_n$&lt;&#x2F;li&gt;
&lt;li&gt;$l_n \sqcup y_{n + 1}$ for some $y_{n + 1} \in Y$ such that $y_{n + 1} \not\sqsubseteq l_n$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Essentially, the sequence starts with $y_0$, and each successive element is obtained by joining it with an element of $Y$ that is not less than the latest element of the sequence, and does so until the sequence arrives at an element of $L$ that is greater than every element of $Y$, and remains that way indefinitely.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the sequence $l_0, l_1, \dots$ is an ascending chain. Furthermore, because $(L, \sqsubseteq)$ meets the ascending chain condition, this ascending chain eventually stabilizes, so there is some $n$ such that $l_n = l_{n + 1} = l_{n + 2} = \dots$. However, the chain itself is not particularly important. The key part of the construction of this chain is that it eventually stabilizes, and based on its construction, it means that eventually after a finite number of elements, we get to a point such that there is some $l_n$ where subsequent elements are the same, and that means that this $l_n$ satisfies the property of being greater than all elements in $Y$—making this an upper bound of $Y$ (otherwise, it means that there is some $y$ such that $y \not\sqsubseteq l_n$, and therefore $y \sqcup l_n \neq l_n$, which would be a contradiction&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;$l_n$ is in fact the &lt;strong&gt;least&lt;&#x2F;strong&gt; upper bound i.e. supremum of $Y$, by virtue of the fact that $l_n$ is the least upper bound of the subset of $Y$ $\{y_0, y_1,\dots,y_n\}$ because it is constructed by $y_0 \sqcup y_1\sqcup \dots\sqcup y_n$. Thus, since $l_n$ is an upper bound of $Y$, and is the least upper bound of $\{y_0,y_1,\dots,y_n\}$, it is also the least upper bound of $Y$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Therefore, requiring a partially ordered set be a complete lattice that satisfies the ascending chain condition is no stricter, and is in fact equivalent, as requiring it to have $\bot$, joins and meet the ascending chain condition.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-brief-introduction-to-datalog&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-brief-introduction-to-datalog&quot; aria-label=&quot;Anchor link for: a-brief-introduction-to-datalog&quot;&gt;A Brief Introduction to Datalog&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;As stated in the &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;flix&#x2F;#introduction&quot;&gt;introduction&lt;&#x2F;a&gt;, Datalog programs consists of facts and rules. Facts are essentially rules with no premise.&lt;&#x2F;p&gt;
&lt;p&gt;We show the syntax of a datalog program here.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#61676c;&quot;&gt;&lt;code&gt;&lt;span&gt;P ::= R1, ..., Rn           program
&lt;&#x2F;span&gt;&lt;span&gt;R ::= A0 :- A1, ..., An     rule
&lt;&#x2F;span&gt;&lt;span&gt;A ::= p(t1, ..., tn)        atom
&lt;&#x2F;span&gt;&lt;span&gt;t ::= x | v                 term
&lt;&#x2F;span&gt;&lt;span&gt;p   = an element of a finite set of predicate symbols
&lt;&#x2F;span&gt;&lt;span&gt;x   = an element of a finite set of variables
&lt;&#x2F;span&gt;&lt;span&gt;v   = an element of a finite set of values
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Every Datalog program satisfies &lt;strong&gt;range restriction&lt;&#x2F;strong&gt;, i.e. in the production &lt;code&gt;R&lt;&#x2F;code&gt; above, every variable appearing in the head of the rule (&lt;code&gt;A0&lt;&#x2F;code&gt;) must also appear in the body &lt;code&gt;A1, ..., An&lt;&#x2F;code&gt;. The following is an example Datalog program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;datalog&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-datalog &quot;&gt;&lt;code class=&quot;language-datalog&quot; data-lang=&quot;datalog&quot;&gt;&lt;span&gt;A(1)
&lt;&#x2F;span&gt;&lt;span&gt;B(2, 3)
&lt;&#x2F;span&gt;&lt;span&gt;A(x) :- B(x, _)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;semantics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#semantics&quot; aria-label=&quot;Anchor link for: semantics&quot;&gt;Semantics&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There are several ways to describe the semantics of a Datalog program. The most straightforward way to do so is to do so model-theoretically.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;model-theoretic-semantics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#model-theoretic-semantics&quot; aria-label=&quot;Anchor link for: model-theoretic-semantics&quot;&gt;Model-Theoretic Semantics&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Ground Terms and Atoms).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;ground term&lt;&#x2F;strong&gt; is a non-variable constant value appearing somewhere in a program.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;ground atom&lt;&#x2F;strong&gt; is a predicate symbol whose arguments are ground terms.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;ground rule&lt;&#x2F;strong&gt; is a rule where all atoms are ground.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Herbrand Universe and Base of Datalog Program).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;The &lt;strong&gt;Herbrand Universe&lt;&#x2F;strong&gt; $\mathcal{U}$ of a Datalog program $P$ is the set of all ground terms appearing in $P$.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;strong&gt;Herbrand Base&lt;&#x2F;strong&gt; $\mathcal{B}$ of a Datalog program $P$ is the set of all ground atoms where the predicate appears in $P$ and whose arguments are drawn from $\mathcal{U}$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Given the Datalog program&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;datalog&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-datalog &quot;&gt;&lt;code class=&quot;language-datalog&quot; data-lang=&quot;datalog&quot;&gt;&lt;span&gt;A(1)
&lt;&#x2F;span&gt;&lt;span&gt;B(2, 3)
&lt;&#x2F;span&gt;&lt;span&gt;A(x) :- B(x, _)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have $\mathcal{U} = \{1, 2, 3\}$ and $\mathcal{B} = \{A(1), A(2), A(3), B(1, 1), B(1, 2), B(1, 3), B(2, 1), B(2, 2), B(2, 3), B(3, 1), B(3, 2), B(3, 3)\}$&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;As you can see, the Herbrand Base $\mathcal{B}$ describes the set of all &lt;strong&gt;possible&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; facts.&lt;&#x2F;p&gt;
&lt;p&gt;The model-theoretic semantics define the &lt;em&gt;minimal model&lt;&#x2F;em&gt; of a Datalog program to be its meaning.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Interpretation of Datalog Program).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;An &lt;strong&gt;interpretation&lt;&#x2F;strong&gt; $I$ of a Datalog program $P$ is a subset $I \subseteq \mathcal{B}$.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A ground atom $A$ is true w.r.t. an interpretation $I$ if $A \in I$.&lt;&#x2F;li&gt;
&lt;li&gt;A conjunction of atoms $A_1,\dots,A_n$ is true w.r.t. an interpretation if each atom is true in the interpretation.&lt;&#x2F;li&gt;
&lt;li&gt;A ground rule is true w.r.t. to an interpretation if either the body conjunction is false or the head is true.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;This allows us to describe the &lt;em&gt;minimal Herbrand model of a Datalog program&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Ground Instance).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A ground rule $R_1$ is a &lt;strong&gt;ground instance&lt;&#x2F;strong&gt; of another rule $R_2$ if $R_1$ is the result of a substitution of constants for all the variables in $R_2$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;From our example program, &lt;code&gt;A(1) :- B(1, 3)&lt;&#x2F;code&gt; is a ground instance of the rule &lt;code&gt;A(x) :- B(x, _)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition (Model).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A model $M$ of a Datalog program $P$ is an interpretation that makes every ground instance of every rule in $P$ true. A model $M$ of a Datalog program $P$ is a &lt;strong&gt;minimal Herbrand model&lt;&#x2F;strong&gt; if no other models $M&#x27;$ of $P$ are such that $M&#x27; \subset M$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Let us go back to our example program and list out every single ground instance of every rule in the program.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;datalog&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-datalog &quot;&gt;&lt;code class=&quot;language-datalog&quot; data-lang=&quot;datalog&quot;&gt;&lt;span&gt;A(1);
&lt;&#x2F;span&gt;&lt;span&gt;B(2, 3);
&lt;&#x2F;span&gt;&lt;span&gt;A(1) :- B(1, 1); A(1) :- B(1, 2); A(1) :- B(1, 3);
&lt;&#x2F;span&gt;&lt;span&gt;A(2) :- B(2, 1); A(2) :- B(2, 2); A(2) :- B(2, 3);
&lt;&#x2F;span&gt;&lt;span&gt;A(3) :- B(3, 1); A(3) :- B(3, 2); A(3) :- B(3, 3);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each of these are ground rules (the first two rules are facts in the Datalog program, which are just rules without a body). The goal is to find an interpretation that makes all these rules true.&lt;&#x2F;p&gt;
&lt;p&gt;The empty interpretation $\emptyset$ is not a model of $P$. This is because the first two ground rules are not true with respect to $\emptyset$.&lt;&#x2F;p&gt;
&lt;p&gt;However, the interpretation $\{A(1), B(2, 3)\}$ is not a model of $P$ either. This is because although the first two ground rules are now true, the rules &lt;code&gt;A(2) :- B(2, 3)&lt;&#x2F;code&gt; is false because &lt;code&gt;B(2, 3)&lt;&#x2F;code&gt; is true but &lt;code&gt;A(2)&lt;&#x2F;code&gt; is false. The other rules are true because the body of the rules are false.&lt;&#x2F;p&gt;
&lt;p&gt;One valid model is $\{A(1), A(2), B(1, 1), B(2, 3)\}$, which makes all the rules true. However, it is not minimal. Instead the model $\{A(1), A(2), B(2, 3)\}$ is the minimal model of the program.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;h3 id=&quot;fixed-point-semantics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixed-point-semantics&quot; aria-label=&quot;Anchor link for: fixed-point-semantics&quot;&gt;Fixed-Point Semantics&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;TODO.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;If $x \not\sqsubseteq y$ then $x \sqcup y \neq y$. This is showed immediately by contradiction. Suppose $x \not \sqsubseteq y$ but $x \sqcup y = y$. By definition of $\sqcup$ it means that $x \sqsubseteq (x \sqcup y)$ i.e. $x \sqsubseteq y$, which is a contradiction.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;The Herbrand Base $\mathcal{B}$ does not consist &lt;strong&gt;only&lt;&#x2F;strong&gt; of &quot;true facts&quot;, i.e. there could be &quot;facts&quot; that should not be derived from the rules and facts existing in the program. $\mathcal{B}$ simply consists of all ground atoms that &lt;strong&gt;could&lt;&#x2F;strong&gt; possibly be derived from the program.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h1 id=&quot;references&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#references&quot; aria-label=&quot;Anchor link for: references&quot;&gt;References&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;a id=&quot;flix&quot; style=&quot;font-size: 0.8em&quot;&gt;
&lt;strong&gt;Magnus Madsen, Ming-Ho Yee, and Ondřej Lhoták. 2016&lt;&#x2F;strong&gt;. From Datalog to Flix: A Declarative Language for Fixed Points on Lattices. In &lt;i&gt;Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &#x27;16)&lt;&#x2F;i&gt;. Association for Computing Machinery, New York, NY, USA, 194–208. https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;2908080.2908096
&lt;&#x2F;a&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Functors and Monads</title>
        <published>2023-12-18T00:00:00+00:00</published>
        <updated>2023-12-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yongqi.foo/blog/posts/monads/"/>
        <id>https://yongqi.foo/blog/posts/monads/</id>
        
        <content type="html" xml:base="https://yongqi.foo/blog/posts/monads/">&lt;h1 id=&quot;motivation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation&quot; aria-label=&quot;Anchor link for: motivation&quot;&gt;Motivation&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;If you have done some functional programming before, you would have probably come across and used functors, monads, polymorphic functions, and maybe even monoids. You may also likely have heard that these terms are defined in &lt;strong&gt;category theory&lt;&#x2F;strong&gt;. However, without any knowledge of category theory, sayings like &quot;a monad is just a monoid in the category of endofunctors, what&#x27;s the problem?&quot; can be incredibly frustrating, and the connections between functors and monads in the programming sense and those in category theory are not immediately apparent.&lt;&#x2F;p&gt;
&lt;p&gt;Through this article I hope to give readers enough background in category theory to understand that functors, monads etc. in the usual programming sense do not only correspond loosely to those found in category theory, but are indeed exactly the same, i.e. a functor in the programming sense is exactly a functor in some category. However, I shall not cover functional programming fundamentals; these are presumed to be understood and known by the reader (readers who have not acquired sufficient background can do so with the wide variety of resources online). Instead, this article draws equalities between the functional programming constructs we know of, and their category-theoretic definitions. In addition, due to this presumption, the majority of this article starts with the math before showing the correspondence with code.&lt;&#x2F;p&gt;
&lt;p&gt;In this article, I offer to show:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The definition of a category, showing that we can assemble types in a programming language into one &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#categories&quot;&gt;(#Categories)&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Functors in the usual programming sense are exactly categorical functors on our category of types &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#functors&quot;&gt;(#Functors)&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Product and function types in the usual programming sense are precisely product and exponential objects in our category of types &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#universal-properties&quot;&gt;(#Universal Properties)&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Monoids in the usual programming sense are precisely monoids in our category of types induced by the categorical product and the unit type &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#monoids&quot;&gt;(#Monoids)&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Monads in the usual programming sense are precisely monads on our category of types, which are monoids in the category of endofunctors of our category of types, which is a strict monoidal category induced by functor composition and the identity functor &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#monads&quot;&gt;(#Monads)&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Monads in the usual programming sense that obey the monad laws in the usual programming sense, precisely define monads in the categorical sense.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;categories&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#categories&quot; aria-label=&quot;Anchor link for: categories&quot;&gt;Categories&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;To even begin our discussion we must first describe what category theory is. Intuitively, most theories (especially the algebraic ones) study mathematical structures that abstract over things; groups are abstractions of symmetries, and geometric spaces are abstractions of space. Category theory takes things one step further and study abstraction itself.&lt;&#x2F;p&gt;
&lt;p&gt;Effectively the goal of category theory is to observe similar underlying structures between collections of mathematical structures. What is nice about this is that a result from category theory generalizes to all other theories that fit the structure of a category. As such it should be no surprise that computation can be studied in category theory too!&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, the generality of category theory also makes it incredibly abstract and difficult to understand—this is indeed the case in our very first definition. As such, I will, as much as possible, show you &quot;concrete&quot; examples of each definition and reason about them if I can. With this in mind, let us start with the definition of a category, as seen in many sources.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 1 (Category).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A category $\mathcal{C}$ consists of &lt;ul&gt;&lt;li&gt;a collection of &lt;b&gt;objects&lt;&#x2F;b&gt;, $X, Y, Z, \dots$, denoted $\text{ob}(\mathcal{C})$&lt;&#x2F;li&gt;&lt;li&gt;a collection of &lt;b&gt;morphisms&lt;&#x2F;b&gt;, $f, g, h, \dots$, denoted $\text{mor}(\mathcal{C})$&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;so that:&lt;ul&gt;&lt;li&gt;Each morphism has specified &lt;b&gt;domain&lt;&#x2F;b&gt; and &lt;b&gt;codomain&lt;&#x2F;b&gt; objects; when we write $f: X \to Y$, we mean that the morphism $f$ has domain $X$ and codomain $Y$.&lt;&#x2F;li&gt;&lt;li&gt;Each object has an &lt;b&gt;identity morphism&lt;&#x2F;b&gt; $1_X:X\rightarrow X$.&lt;&#x2F;li&gt;&lt;li&gt;For any pair of morphisms $f$, $g$ with the codomain of $f$ equal to the domain of $g$ (i.e. $f$ and $g$ are composable), there exists a &lt;b&gt;composite morphism&lt;&#x2F;b&gt; $g \circ f$ whose domain is equal to the domain of $f$ and whose codomain is equal to the codomain of $g$, i.e. $$
f: X\rightarrow Y, ~~~g: Y \rightarrow Z ~~~~~ \rightsquigarrow ~~~~~ g\circ f:X\rightarrow Z
$$
&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Composition of morphisms is subject to the two following axioms:
&lt;ul&gt;&lt;li&gt;
&lt;b&gt;Unity&lt;&#x2F;b&gt;. For any $f: X \rightarrow Y$, $f\circ1_X = 1_Y \circ f = f$.&lt;&#x2F;li&gt;&lt;li&gt;
&lt;b&gt;Associativity&lt;&#x2F;b&gt;. For any composable $f$, $g$ and $h$, $(h\circ g)\circ f = h \circ (g \circ f)$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;As you can see, there is very little describing what a category is, or how to construct one. In category theory, we do not care (that much) about the construction of objects of morphisms; as long as they satisfy the definition of a category, we may work with them in a categorical framework. This allows many different kinds of objects to all assemble into categories.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 1.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;The category of sets, $\textbf{Set}$, contains sets (like $\mathbb{N}$ and ${1, 2, 3}$) as objects, and as morphisms, functions between sets (like $f: \mathbb{R} \rightarrow \mathbb{R}, f(x) = x^2 + 2x + 3$). From this example, we can see that there can be more than one morphism between two objects in a category. The identity morphism for each object $\mathbb{A}$ is the function $1_\mathbb{A}: \mathbb{A} \rightarrow \mathbb{A}$ where $1_\mathbb{A}(x) = x$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Our construction of $\textbf{Set}$ indeed forms a category&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem 1.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$\textbf{Set}$ is a category.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. Given objects (sets) $\mathbb{A}$, $\mathbb{B}$ and $\mathbb{C}$ and morphisms (functions) $f: \mathbb{A} \rightarrow \mathbb{B}$ and $g: \mathbb{B} \rightarrow {C}$, the composite $g \circ f: \mathbb{A} \rightarrow \mathbb{C}$ exists in $\textbf{Set}$, given by $(g \circ f)(x) = g(f(x))$. Similarly, we can see that $(1_\mathbb{B} \circ f)(x) = 1_\mathbb{B}(f(x)) = f(x)$ and $(f \circ 1_\mathbb{A})(x) = f(1_\mathbb{A}(x)) = f(x)$, therefore showing that composition is unital. Finally, composition of functions is also associative; suppose we have another morphism $h: \mathbb{C} \rightarrow \mathbb{D}$, then $((h \circ g) \circ f)(x) = (h \circ g)(f(x)) = h(g(f(x))$, and $(h \circ (g \circ f))(x) = h((g \circ f)(x)) =h(g(f(x))$ too.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;As stated earlier, many kinds of objects assemble into categories. Example 2 gives an example category that has (virtually) nothing to do with $\textbf{Set}$. This category&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; we shall show will be used everywhere in this article.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 2.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose some simple types in a type system exist. We can construct a category $\mathcal{T}$ where the objects are types, and the morphisms are functions on those types, i.e. a function from &lt;code&gt;A&lt;&#x2F;code&gt; to &lt;code&gt;B&lt;&#x2F;code&gt; will be a morphism from &lt;code&gt;A&lt;&#x2F;code&gt; to &lt;code&gt;B&lt;&#x2F;code&gt; in this category—these are functions of the type &lt;code&gt;A -&amp;gt; B&lt;&#x2F;code&gt;. In this category, composition of morphisms is straightforward: if &lt;code&gt;f :: A -&amp;gt; B&lt;&#x2F;code&gt; and &lt;code&gt;g :: B -&amp;gt; C&lt;&#x2F;code&gt; then its composition is &lt;code&gt;(g . f) x = g (f x)&lt;&#x2F;code&gt;. Similarly, for any type &lt;code&gt;A&lt;&#x2F;code&gt; the identity morphism is the identity function &lt;code&gt;id :: A -&amp;gt; A&lt;&#x2F;code&gt; where &lt;code&gt;id x = x&lt;&#x2F;code&gt;. We can show that what we have constructed is indeed a category, by similar proofs of associativity and unity shown in the proof of Theorem 1.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Composition in categories can be described by the following &lt;strong&gt;commutative diagram&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, that is, the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMyxbMCwwLCJBIl0sWzEsMCwiQiJdLFsxLDEsIkMiXSxbMCwxLCJmIl0sWzEsMiwiZyJdLFswLDIsImdcXGNpcmMgZiIsMl0sWzAsMCwiMV9BIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6LTQ1fV0sWzEsMSwiMV9CIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6NDV9XSxbMiwyLCIxX0MiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjotMTgwfV1d&amp;embed&quot; width=&quot;300&quot; height=&quot;300&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;In other words, going from object $A$ to $B$ via morphism $f$ then from $B$ to $C$ via $g$ is the same as going from $A$ to $C$ directly via $g\circ f$. Such commutative diagrams will be useful for describing and defining further concepts later.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;functors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#functors&quot; aria-label=&quot;Anchor link for: functors&quot;&gt;Functors&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In mathematics, the relationships between objects are frequently far more interesting than the objects themselves. Of course, we do not just focus on &lt;strong&gt;any&lt;&#x2F;strong&gt; relationship between objects, but of keen interest, the &lt;em&gt;structure preserving&lt;&#x2F;em&gt; relationships between them, such as group homomorphisms that preserve group structures, or monotonic functions between preordered sets that preserve ordering. In category theory, &lt;strong&gt;functors&lt;&#x2F;strong&gt; are maps between categories that preserve the structure of the domain category, especially the compositions and identities.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 2 (Functor).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;
    Let $\mathcal{C}$ and $\mathcal{D}$ be categories. A (&lt;strong&gt;covariant&lt;&#x2F;strong&gt;) &lt;strong&gt;functor&lt;&#x2F;strong&gt; $F: \mathcal{C} \rightarrow \mathcal{D}$ consists of:
&lt;ul&gt;
&lt;li&gt;An object $F(C) \in \text{ob}(\mathcal{D})$ for each object $C \in \text{ob}(\mathcal{C})$.&lt;&#x2F;li&gt;
        &lt;li&gt;A morphism $F(f): F(C) \rightarrow F(D) \in \text{mor}(\mathcal{D})$ for each morphism $f: C\rightarrow D \in \text{mor}(\mathcal{C})$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
    subject to the two &lt;strong&gt;functoriality axioms&lt;&#x2F;strong&gt;:
&lt;ul&gt;
        &lt;li&gt;For any composable pair of morphisms $f, g\in\text{mor}(\mathcal{C})$, $F(g)\circ F(f) = F(g\circ f)$.&lt;&#x2F;li&gt;
         &lt;li&gt;For each $C \in \text{ob}(\mathcal{C})$, $F(1_C)=1_{F(C)}$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
    in other words, functors respect composition and identities.
&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Note that when writing $C \in \text{ob}(\mathcal{C})$ we abuse the notation of set membership. It is not necessary for the collections of objects and morphisms of a category to be sets, as is the case for $\text{ob}(\textbf{Set})$.&lt;&#x2F;p&gt;
&lt;p&gt;We show two diagrams below, where on the left we have a diagram in $\mathcal{C}$ and on the right we have a diagram in $\mathcal{D}$. Given a functor $F: \mathcal{C} \rightarrow \mathcal{D}$, the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQiJdLFsxLDEsIkMiXSxbNCwwLCJGKEEpIl0sWzUsMCwiRihCKSJdLFs1LDEsIkYoQykiXSxbMCwxLCJmIl0sWzEsMiwiZyJdLFswLDIsImdcXGNpcmMgZiIsMl0sWzAsMCwiMV9BIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6LTQ1fV0sWzEsMSwiMV9CIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6NDV9XSxbMiwyLCIxX0MiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjotMTgwfV0sWzQsNSwiRihnKSJdLFszLDQsIkYoZikiXSxbMyw1LCJGKGdcXGNpcmMgZikiLDIseyJsYWJlbF9wb3NpdGlvbiI6MjB9XSxbMywzLCJGKDFfQSkiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjotNDV9XSxbNCw0LCJGKDFfQikiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjo0NX1dLFs1LDUsIkYoMV9DKSIsMCx7InJhZGl1cyI6MSwiYW5nbGUiOjEzNX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQiJdLFsxLDEsIkMiXSxbNCwwLCJGKEEpIl0sWzUsMCwiRihCKSJdLFs1LDEsIkYoQykiXSxbMCwxLCJmIl0sWzEsMiwiZyJdLFswLDIsImdcXGNpcmMgZiIsMl0sWzAsMCwiMV9BIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6LTQ1fV0sWzEsMSwiMV9CIiwwLHsicmFkaXVzIjoxLCJhbmdsZSI6NDV9XSxbMiwyLCIxX0MiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjotMTgwfV0sWzQsNSwiRihnKSJdLFszLDQsIkYoZikiXSxbMyw1LCJGKGdcXGNpcmMgZikiLDIseyJsYWJlbF9wb3NpdGlvbiI6MjB9XSxbMywzLCJGKDFfQSkiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjotNDV9XSxbNCw0LCJGKDFfQikiLDAseyJyYWRpdXMiOjEsImFuZ2xlIjo0NX1dLFs1LDUsIkYoMV9DKSIsMCx7InJhZGl1cyI6MSwiYW5nbGUiOjEzNX1dXQ==&amp;embed&quot; width=&quot;800&quot; height=&quot;500&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 3.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;
The powerset functor $P: \textbf{Set} \rightarrow \textbf{Set}$ maps a set $\mathbb{A}$ to its powerset $P(\mathbb{A}) = \mathcal{P}(\mathbb{A})$ and a function $f: \mathbb{A} \rightarrow \mathbb{B}$ to $P(f): P(\mathbb{A}) \rightarrow P(\mathbb{B})$ defined by
&lt;p&gt;$$
P(f)(\mathbb{X}) = \{f(x) \ |\  x \in \mathbb{X}\}
$$&lt;&#x2F;p&gt;
&lt;p&gt;In other words, $P$ lifts a function of elements of $\mathbb{A}$ into a function of subsets of $\mathbb{A}$.&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem 2.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$P$ is a functor.&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. $P$ respects composition. Suppose we have $f: \mathbb{A} \rightarrow \mathbb{B}$ and $g: \mathbb{B} \rightarrow \mathbb{C}$, then $P(g \circ f)(\mathbb{X}) = \{(g \circ f)(x)\ |\ x \in \mathbb{X}\} = \{g(f(x))\ |\ x \in \mathbb{X}\}$ and $(P(g) \circ P(f))(\mathbb{X}) = P(g)(\{f(x)\ |\ x \in \mathbb{X}\}) = \{g(f(x))\ |\ x \in \mathbb{X}\}$. $P$ also respects identities. Given $1_\mathbb{X}: \mathbb{X} \rightarrow \mathbb{X}$ where $1_\mathbb{X}(x) = x$, then $P(1_\mathbb{X})(\mathbb{X}) = \{1_\mathbb{X}(x)\ |\ x \in \mathbb{X}\} = \{x\ |\ x \in \mathbb{X}\} = \mathbb{X}$, thus showing that $P(1_\mathbb{X}) = 1_{P(\mathbb{X})}$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;The powerset functor is one example of an &lt;strong&gt;endofunctor&lt;&#x2F;strong&gt;, which is a functor that has equal domain and codomain categories.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 4.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;In many languages, the list type is a type constructor that receives a type and produces a list of that type. For example, the &lt;code&gt;[Int]&lt;&#x2F;code&gt; type is produced from passing in the &lt;code&gt;Int&lt;&#x2F;code&gt; type into the &lt;code&gt;[]&lt;&#x2F;code&gt; type constructor. We shall denote the list type constructor as &lt;code&gt;[]&lt;&#x2F;code&gt;, sort of as a function on types, for example, &lt;code&gt;[] Int = [Int]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, we can define a higher order function &lt;code&gt;lmap&lt;&#x2F;code&gt; that lifts a function on elements to one on a list of those elements, like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;lmap &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [a] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [b]
&lt;&#x2F;span&gt;&lt;span&gt;lmap f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;lmap f (x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; xs) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; f x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lmap f xs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As an example, &lt;code&gt;lmap length [&quot;abc&quot;, &quot;de&quot;]&lt;&#x2F;code&gt; gives &lt;code&gt;[3, 2]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Then, let $\mathcal{T}$ be the category of types described in Example 2. We can define an endofunctor $L: \mathcal{T} \rightarrow \mathcal{T}$ that maps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;each object (type) $\mathtt{A} \in \text{ob}(\mathcal{T})$ to the type $L(\mathtt{A}) = \mathtt{[]}(\mathtt{A}) = \mathtt{[A]}$&lt;&#x2F;li&gt;
&lt;li&gt;each morphism (function) &lt;code&gt;f :: A -&amp;gt; B&lt;&#x2F;code&gt; $\in \text{mor}(\mathcal{T})$ to the function $L(\mathtt{f}) =$&lt;code&gt;lmap f :: [A] -&amp;gt; [B]&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The functoriality of $L$ should be straightforward to verify.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;In many programming texts, a type constructor (together with its implementation of &lt;code&gt;lmap&lt;&#x2F;code&gt;) is a functor if we have:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#61676c;&quot;&gt;&lt;code&gt;&lt;span&gt;lmap (g . f) ==== lmap g . lmap f
&lt;&#x2F;span&gt;&lt;span&gt;     lmap id ==== id
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should be immediately clear that our definition of &lt;code&gt;lmap&lt;&#x2F;code&gt; satisfies them. Also, you should notice that the functor laws described in the usual programming sense is precisely what is needed to define a categorical functor in $\mathcal{T}$. As such, we can define any arbitrary functor (in the programming sense) that maps types via a type constructor and lifts function on types into functions on the types after applying the type constructor. As long as this functor satisfies the functor laws, this specifies a functor on $\mathcal{T}$! This is precisely the motivation for the &lt;code&gt;Functor&lt;&#x2F;code&gt; typeclass in Haskell:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#55b4d4;&quot;&gt;Functor&lt;&#x2F;span&gt;&lt;span&gt; (f :: * -&amp;gt; *) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;fmap &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;f a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;f b
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, the type constructor &lt;code&gt;f&lt;&#x2F;code&gt; is a &lt;code&gt;Functor&lt;&#x2F;code&gt; when it is equipped with a way to lift functions via &lt;code&gt;fmap&lt;&#x2F;code&gt; (subject to the functoriality axioms). Since the list type constructor is already a &lt;code&gt;Functor&lt;&#x2F;code&gt;, it provides a definition of &lt;code&gt;fmap&lt;&#x2F;code&gt; that is identical to &lt;code&gt;lmap&lt;&#x2F;code&gt; which we defined earlier. We can even define our own type constructors and allow them to be &lt;code&gt;Functor&lt;&#x2F;code&gt;s by providing their definitions of &lt;code&gt;fmap&lt;&#x2F;code&gt; as long as they respect composition and identities. I show an example of defining our own functor below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Our own type constructor
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;deriving &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Show
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- fmap definition
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Functor Box where
&lt;&#x2F;span&gt;&lt;span&gt;    fmap f (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; x) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fmap (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box 3&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Box 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The definition of a category does not necessarily preclude any particular object from being a part of a category; as such, it stands to reason that categories themselves can assemble into a category&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. In such a category, the objects are categories themselves, and the morphisms between categories are functors between them. The identities for each category $\mathcal{C}$, denoted $1_\mathcal{C}$, are their corresponding identity functor (mapping each object and morphism to themselves) and composition of morphisms is defined by the composition of functors. The composition of functors $F: \mathcal{C} \rightarrow \mathcal{D}$ and $G: \mathcal{D} \rightarrow \mathcal{E}$ is $G \circ F: \mathcal{C} \rightarrow \mathcal{E}$ such that for each object $X$ in $\mathcal{C}$ we have $G(F(X))$ in $\mathcal{E}$, and for each morphism $f$ in $\mathcal{C}$ we have $G(F(f))$ in $\mathcal{E}$. Associativity and unity of functor composition should be relatively straightforward to show.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;universal-properties&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#universal-properties&quot; aria-label=&quot;Anchor link for: universal-properties&quot;&gt;Universal Properties&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In many instances we want to characterize an object with some unique property in relation to other objects in a category via morphisms, without needing to deal with the details of some particular construction. This allows us to discover results of these objects without needing to repeat the same proofs in different categories. This is what is known as a universal property.&lt;&#x2F;p&gt;
&lt;p&gt;Before defining universal properties, we shall look at some examples of them first. Suppose we are in \textbf{Set} and we have sets $\mathbb{A}$ and $\mathbb{B}$. We would like to find some set $\mathbb{P}$ and functions $\pi_1: \mathbb{P} \rightarrow \mathbb{A}$ and $\pi_2: \mathbb{P} \rightarrow \mathbb{B}$ such that, for all sets $\mathbb{X}$ and functions $f_{\mathbb{X}\mathbb{A}}: \mathbb{X} \rightarrow \mathbb{A}$ and $f_{\mathbb{X}\mathbb{B}}: \mathbb{X} \rightarrow \mathbb{B}$, there exists a function $p: \mathbb{X} \rightarrow \mathbb{P}$ so that $\pi_1 \circ p = f_{\mathbb{X}\mathbb{A}}$ and $\pi_2 \circ p = f_{\mathbb{X}\mathbb{B}}$. In simple terms, we are looking for $\mathbb{P}$, $\pi_1$ and $\pi_2$ that allows $\mathbb{P}$ to be a `common pit stop&#x27;, or in other words, there will exist $p$ that encodes the data of both $f_{\mathbb{X}\mathbb{A}}$ and $f_{\mathbb{X}\mathbb{B}}$. As a commutative diagram, given objects $\mathbb{A}$ and $\mathbb{B}$, we want to find object $\mathbb{P}$ and morphisms $\pi_1$ and $\pi_2$ such that for all objects $\mathbb{X}$ and morphisms $f_{\mathbb{X}\mathbb{A}}$ and $f_{\mathbb{X}\mathbb{B}}$, there exists $p$ so that the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJcXG1hdGhiYntYfSJdLFsxLDEsIlxcbWF0aGJie1B9Il0sWzAsMSwiXFxtYXRoYmJ7QX0iXSxbMiwxLCJcXG1hdGhiYntCfSJdLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMSwicCJdLFswLDIsImZfe1xcbWF0aGJie1hBfX0iLDJdLFswLDMsImZfe1xcbWF0aGJie1hCfX0iXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJcXG1hdGhiYntYfSJdLFsxLDEsIlxcbWF0aGJie1B9Il0sWzAsMSwiXFxtYXRoYmJ7QX0iXSxbMiwxLCJcXG1hdGhiYntCfSJdLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMSwicCJdLFswLDIsImZfe1xcbWF0aGJie1hBfX0iLDJdLFswLDMsImZfe1xcbWF0aGJie1hCfX0iXV0=&amp;embed&quot; width=&quot;432&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;It turns out that the cartesian product of $\mathbb{A}$ and $\mathbb{B}$, i.e. $\mathbb{A} \times \mathbb{B}$, is a construction of $\mathbb{P}$:
$$\mathbb{A} \times \mathbb{B} = \{ (a, b) \ |\  a \in \mathbb{A}, b \in \mathbb{B}\}$$
and the following functions are constructions of $\pi_1$ and $\pi_2$: $\pi_1(a, b) = a$ and $\pi_2(a, b) = b$. This is so that given functions $f_{\mathbb{X}\mathbb{A}}: \mathbb{X} \rightarrow \mathbb{A}$ and $f_{\mathbb{X}\mathbb{B}}: \mathbb{X} \rightarrow \mathbb{B}$, $p: \mathbb{X} \rightarrow \mathbb{P}$ would be the function $p(x) = (f_{\mathbb{X}\mathbb{A}}(x), f_{\mathbb{X}\mathbb{B}}(x))$. The diagram above commutes as $(\pi_1 \circ p)(x) = \pi_1(f_{\mathbb{X}\mathbb{A}}(x), f_{\mathbb{X}\mathbb{B}}(x)) = f_{\mathbb{X}\mathbb{A}}(x)$, and $(\pi_2 \circ p)(x) = \pi_2(f_{\mathbb{X}\mathbb{A}}(x), f_{\mathbb{X}\mathbb{B}}(x)) = f_{\mathbb{X}\mathbb{B}}(x)$.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, notice that given our construction of $\mathbb{P}$, $\pi_1$ and $\pi_2$, $p$ is unique. Suppose $p$ is not unique, and there is another morphism $p&#x27;: \mathbb{X} \rightarrow \mathbb{P}$ such that $\pi_1 \circ p&#x27; = f_{\mathbb{X}\mathbb{A}}$ and $\pi_2 \circ p&#x27; = f_{\mathbb{X}\mathbb{B}}$ where $p \neq p&#x27;$. This means that $p&#x27;(x) = (y, z)$ where either $y \neq f_{\mathbb{X}\mathbb{A}}(x)$ or $z \neq f_{\mathbb{X}\mathbb{B}}(x)$. We also know that $\pi_1(y, z) = y$ and $\pi_2(y, z) = z$. As such, either $(\pi_1 \circ p&#x27;)(x) = y \neq f_{\mathbb{X}\mathbb{A}}(x)$ or $(\pi_1 \circ p&#x27;)(x) = z \neq f_{\mathbb{X}\mathbb{B}}(x)$ so either $\pi_1 \circ p&#x27; \neq f_{\mathbb{X}\mathbb{A}}$ or $\pi_2 \circ p&#x27; \neq f_{\mathbb{X}\mathbb{B}}$, which is a contradiction.&lt;&#x2F;p&gt;
&lt;p&gt;We can now re-draw our commutative diagram, where dashed arrows represent a unique morphism:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJcXG1hdGhiYntYfSJdLFsxLDEsIlxcbWF0aGJie1B9Il0sWzAsMSwiXFxtYXRoYmJ7QX0iXSxbMiwxLCJcXG1hdGhiYntCfSJdLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMSwicCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsImZfe1xcbWF0aGJie1hBfX0iLDJdLFswLDMsImZfe1xcbWF0aGJie1hCfX0iXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJcXG1hdGhiYntYfSJdLFsxLDEsIlxcbWF0aGJie1B9Il0sWzAsMSwiXFxtYXRoYmJ7QX0iXSxbMiwxLCJcXG1hdGhiYntCfSJdLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMSwicCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsImZfe1xcbWF0aGJie1hBfX0iLDJdLFswLDMsImZfe1xcbWF0aGJie1hCfX0iXV0=&amp;embed&quot; width=&quot;432&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;This property we have described completely characterizes the &lt;strong&gt;categorical product&lt;&#x2F;strong&gt; of two objects in $\textbf{Set}$. We can in fact generalize the notion of a product of two objects in any arbitrary category.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 3 (Product).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Fix category $\mathcal{C}$. &lt;p&gt;Given objects $A$ and $B$, the &lt;strong&gt;product&lt;&#x2F;strong&gt; of $A$ and $B$, denoted $A \times B$, equipped with morphisms $\pi_1: A \times B \rightarrow A$ and $\pi_2: A \times B \rightarrow B$, is such that for all objects $X$ and morphisms $f: X \rightarrow A$ and $g: X \rightarrow B$, there exists a unique morphism $p: X \rightarrow A \times B$ (denoted $\langle f, g \rangle$) following diagram commutes:&lt;&#x2F;p&gt;&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJYIl0sWzEsMSwiQVxcdGltZXMgQiJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwxLCJwIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiZiIsMl0sWzAsMywiZyJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJYIl0sWzEsMSwiQVxcdGltZXMgQiJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwxLCJwIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiZiIsMl0sWzAsMywiZyJdXQ==&amp;embed&quot; width=&quot;456&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;The &lt;strong&gt;universality&lt;&#x2F;strong&gt; of $A \times B$ stems from the fact that there exists exactly one $p$, i.e. $p$ exists and is unique, thus denoted $\langle f, g\rangle$. This effectively gives rise to some notion of uniqueness of the product of $A$ and $B$ in any arbitrary category.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 4 (Isomorphism).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Fix category $\mathcal{C}$. Given objects $A$ and $B$, $f: A \rightarrow B$ is an &lt;strong&gt;isomorphism&lt;&#x2F;strong&gt; is there exists $g: B \rightarrow A$ such that $g \circ f = 1_A$ and $f \circ g = 1_B$. If there exists an isomorphism between $A$ and $B$, we say that $A$ and $B$ are &lt;strong&gt;isomorphic&lt;&#x2F;strong&gt;, i.e $A \cong B$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Isomorphisms are important in mathematics because they group objects together that have essentially the same properties despite their different representations. That means that what we discover about one object will also be true of the other. For example, if two groups $G$ and $G&#x27;$ are isomorphic, then showing $G$ is abelian tells us immediately that $G&#x27;$ is also abelian; showing $G&#x27;$ is cyclic tells us immediately that $G$ is also cyclic. Two objects being isomorphic means that the two objects are essentially the same.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem 3.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Fix category $\mathcal{C}$. Given objects $A$ and $B$, if both $P$ and $P&#x27;$ are products of $A$ and $B$, then $P \cong P&#x27;$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;.
By definition 3, because $P$ is a product, there exists a unique morphism $f$ such that the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQIl0sWzEsMSwiUCJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMiwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiXFxwaV8xIiwyXSxbMCwzLCJcXHBpXzIiXSxbMCwxLCIxX1AiLDIseyJvZmZzZXQiOjJ9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQIl0sWzEsMSwiUCJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwxLCJmIiwwLHsib2Zmc2V0IjotMiwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiXFxwaV8xIiwyXSxbMCwzLCJcXHBpXzIiXSxbMCwxLCIxX1AiLDIseyJvZmZzZXQiOjJ9XV0=&amp;embed&quot; width=&quot;432&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;We already know by definition of the identity morphism on $P$ that $\pi_1 = \pi_1 \circ 1_P$ and $\pi_2 = \pi_2 \circ 1_P$. Since $f$ is &lt;strong&gt;unique&lt;&#x2F;strong&gt;, it must be the case that $f$ is precisely $1_P$. This shows that &lt;strong&gt;any&lt;&#x2F;strong&gt; morphism from $P$ to $P$ that satisfies this commutative diagram must be equal to $1_P$.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, since $P&#x27;$ is also a product, the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQJyJdLFsxLDEsIlAnIl0sWzAsMSwiQSJdLFsyLDEsIkIiXSxbMSwyLCJcXHBpXzEnIl0sWzEsMywiXFxwaV8yJyIsMl0sWzAsMSwiZiciLDAseyJvZmZzZXQiOi0yLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCJcXHBpXzEnIiwyXSxbMCwzLCJcXHBpXzInIl0sWzAsMSwiMV97UCd9IiwyLHsib2Zmc2V0IjoyfV1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQJyJdLFsxLDEsIlAnIl0sWzAsMSwiQSJdLFsyLDEsIkIiXSxbMSwyLCJcXHBpXzEnIl0sWzEsMywiXFxwaV8yJyIsMl0sWzAsMSwiZiciLDAseyJvZmZzZXQiOi0yLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCJcXHBpXzEnIiwyXSxbMCwzLCJcXHBpXzInIl0sWzAsMSwiMV97UCd9IiwyLHsib2Zmc2V0IjoyfV1d&amp;embed&quot; width=&quot;432&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;We can argue similarly to show any morphism from $P&#x27;$ to $P&#x27;$ that satisfies the commutative diagram above must be equal to $1_{P&#x27;}$.&lt;&#x2F;p&gt;
&lt;p&gt;Now, again by Definition 3, the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQIl0sWzEsMiwiUCciXSxbMCwxLCJBIl0sWzIsMSwiQiJdLFsxLDIsIlxccGlfMSciXSxbMSwzLCJcXHBpXzInIiwyXSxbMCwxLCJwJyIsMCx7Im9mZnNldCI6LTIsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsIlxccGlfMSIsMl0sWzAsMywiXFxwaV8yIl0sWzEsMCwicCIsMCx7Im9mZnNldCI6LTIsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMSwwLCJQIl0sWzEsMiwiUCciXSxbMCwxLCJBIl0sWzIsMSwiQiJdLFsxLDIsIlxccGlfMSciXSxbMSwzLCJcXHBpXzInIiwyXSxbMCwxLCJwJyIsMCx7Im9mZnNldCI6LTIsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsIlxccGlfMSIsMl0sWzAsMywiXFxwaV8yIl0sWzEsMCwicCIsMCx7Im9mZnNldCI6LTIsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==&amp;embed&quot; width=&quot;432&quot; height=&quot;432&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Collapsing the diagram, once going from $P$ to $P&#x27;$ then back, and the other going from $P&#x27;$ to $P$ and back, gives us two commutative diagrams:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMSwwLCJQIl0sWzEsMSwiUCJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzMsMSwiQSJdLFs0LDEsIlAnIl0sWzQsMCwiUCciXSxbNSwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwyLCJcXHBpXzEiLDJdLFswLDMsIlxccGlfMiJdLFswLDEsInBcXGNpcmMgcCciLDFdLFs2LDQsIlxccGlfMSciLDJdLFs1LDQsIlxccGlfMSciXSxbNSw3LCJcXHBpXzInIiwyXSxbNiw3LCJcXHBpXzInIl0sWzYsNSwicCdcXGNpcmMgcCIsMV1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMSwwLCJQIl0sWzEsMSwiUCJdLFswLDEsIkEiXSxbMiwxLCJCIl0sWzMsMSwiQSJdLFs0LDEsIlAnIl0sWzQsMCwiUCciXSxbNSwxLCJCIl0sWzEsMiwiXFxwaV8xIl0sWzEsMywiXFxwaV8yIiwyXSxbMCwyLCJcXHBpXzEiLDJdLFswLDMsIlxccGlfMiJdLFswLDEsInBcXGNpcmMgcCciLDFdLFs2LDQsIlxccGlfMSciLDJdLFs1LDQsIlxccGlfMSciXSxbNSw3LCJcXHBpXzInIiwyXSxbNiw3LCJcXHBpXzInIl0sWzYsNSwicCdcXGNpcmMgcCIsMV1d&amp;embed&quot; width=&quot;816&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Combining these diagrams with the first two diagrams above shows us that $p \circ p&#x27; = 1_P$ and $p&#x27; \circ p = 1_{P&#x27;}$, which implies that $p$ and $p&#x27;$ are isomorphisms, and therefore $P \cong P&#x27;$. In fact, $P$ and $P&#x27;$ are isomorphic with a &lt;strong&gt;unique&lt;&#x2F;strong&gt; isomorphism $p$ and $p&#x27;$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;This gives further insight as to the &lt;strong&gt;universality&lt;&#x2F;strong&gt; of the categorical product of two objects: that if two objects $P$ and $P&#x27;$ have the universal property of being a product of two other objects $A$ and $B$, then there is a unique isomorphism between $P$ and $P&#x27;$—i.e. the product of $A$ and $B$ is unique up to a unique isomorphism. As such, when speaking of a product of $A$ and $B$, we can describe it as &lt;strong&gt;the&lt;&#x2F;strong&gt; product of $A$ and $B$, which we shall denote as $A \times B$.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 5.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we are in the category of types $\mathcal{T}$ and we have types &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;. Then, the type &lt;code&gt;(A, B)&lt;&#x2F;code&gt;, together with projections &lt;code&gt;fst&#x27; :: (A, B) -&amp;gt; A&lt;&#x2F;code&gt; and &lt;code&gt;snd&#x27; :: (A, B) -&amp;gt; B&lt;&#x2F;code&gt; where &lt;code&gt;fst&#x27; (a, b) = a&lt;&#x2F;code&gt; and &lt;code&gt;snd&#x27; (a, b) = b&lt;&#x2F;code&gt;, is the product of types &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;. That means that given a type &lt;code&gt;X&lt;&#x2F;code&gt; and two functions &lt;code&gt;f :: X -&amp;gt; A&lt;&#x2F;code&gt; and &lt;code&gt;g :: X -&amp;gt; B&lt;&#x2F;code&gt;, we can construct a unique function &lt;code&gt;p :: X -&amp;gt; (A, B)&lt;&#x2F;code&gt; given by &lt;code&gt;p x = (f x, g x)&lt;&#x2F;code&gt; so that &lt;code&gt;fst&#x27; . p == f&lt;&#x2F;code&gt; and &lt;code&gt;snd&#x27; . p == g&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;fst&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span&gt;fst&amp;#39; (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;snd&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; Char
&lt;&#x2F;span&gt;&lt;span&gt;snd&amp;#39; (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; b
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: String -&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; length
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: String -&amp;gt; Char
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; head
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;p &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: String -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;p x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (f x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; g x)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;hello&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f x          &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- 5
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (fst&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; p) x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- 5
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; g x          &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;#39;h&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (snd&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; p) x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;#39;h&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Before we look at another universal property, we shall provide a definition of the product of morphisms, which is similar to what we have seen earlier.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 5 (Product Morphism).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we are in a category $\mathcal{C}$ with pairs of objects $A, A&#x27;$ and $B, B&#x27;$ admitting binary products:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQVxcdGltZXMgQSciXSxbMiwwLCJBJyJdLFswLDEsIkIiXSxbMSwxLCJCXFx0aW1lcyBCJyJdLFsyLDEsIkInIl0sWzEsMCwicF8xIiwyXSxbMSwyLCJwXzIiXSxbNCwzLCJxXzEiLDJdLFs0LDUsInFfMiJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQVxcdGltZXMgQSciXSxbMiwwLCJBJyJdLFswLDEsIkIiXSxbMSwxLCJCXFx0aW1lcyBCJyJdLFsyLDEsIkInIl0sWzEsMCwicF8xIiwyXSxbMSwyLCJwXzIiXSxbNCwzLCJxXzEiLDJdLFs0LDUsInFfMiJdXQ==&amp;embed&quot; width=&quot;465&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;and further suppose we have morphisms $f: A \rightarrow B$ and $f&#x27;: A&#x27;\rightarrow B&#x27;$. Then, the product morphism of $f$ and $f&#x27;$, denoted $f\times f&#x27;$, is the unique morphism that makes the following diagram commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQVxcdGltZXMgQSciXSxbMiwwLCJBJyJdLFswLDEsIkIiXSxbMSwxLCJCXFx0aW1lcyBCJyJdLFsyLDEsIkInIl0sWzAsMywiZiIsMl0sWzEsMCwicF8xIiwyXSxbMSwyLCJwXzIiXSxbMSw0LCJmXFx0aW1lcyBmJyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsyLDUsImYnIl0sWzQsMywicV8xIiwyXSxbNCw1LCJxXzIiXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQVxcdGltZXMgQSciXSxbMiwwLCJBJyJdLFswLDEsIkIiXSxbMSwxLCJCXFx0aW1lcyBCJyJdLFsyLDEsIkInIl0sWzAsMywiZiIsMl0sWzEsMCwicF8xIiwyXSxbMSwyLCJwXzIiXSxbMSw0LCJmXFx0aW1lcyBmJyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsyLDUsImYnIl0sWzQsMywicV8xIiwyXSxbNCw1LCJxXzIiXV0=&amp;embed&quot; width=&quot;465&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
We can see from this diagram that the product of morphisms relates closely to the unique morphism obtained from the definition of the product of objects, i.e. $f \times f&#x27; = \langle f \circ p_1, f&#x27; \circ p_2\rangle$.
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 6.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Forming product morphisms in $\mathcal{T}$ is very similar to obtaining the product of two objects of a type. Let us suppose we have &lt;code&gt;f :: a -&amp;gt; b&lt;&#x2F;code&gt; and &lt;code&gt;g :: a&#x27; -&amp;gt; b&#x27;&lt;&#x2F;code&gt;. Then we can form the product of these two functions; this must be a function from &lt;code&gt;(a, a&#x27;)&lt;&#x2F;code&gt; to &lt;code&gt;(b, b&#x27;)&lt;&#x2F;code&gt;. It can be defined in the most obvious way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;prod&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b&amp;#39;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a, a&amp;#39;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;prod&amp;#39; f g (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; a&amp;#39;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (f a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; g a&amp;#39;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;From this definition, we can now define the following universal property.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 6 (Exponential Object).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we are in category $\mathcal{C}$ with objects $B$ and $C$, and $\mathcal{C}$ contains all binary products with $B$ (i.e., for all objects $X$ in $\mathcal{C}$, the product $X \times B$ exists). Then, the exponential object, denoted $C^B$, equipped with morphism $\epsilon: C^B \times B \rightarrow B$, is an object such that for any object $A$ and morphism $f: A \times B \rightarrow C$, there exists a unique morphism $\lambda f: A \rightarrow C^B$ (called the \emph{transpose} of $f$) that makes the following diagram commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDXkIiXSxbMiwwLCJDXkIgXFx0aW1lcyBCIl0sWzMsMCwiQyJdLFswLDEsIkEiXSxbMiwxLCJBXFx0aW1lcyBCIl0sWzEsMiwiXFxlcHNpbG9uIl0sWzMsMCwiXFxsYW1iZGEgZiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDEsIlxcbGFtYmRhIGZcXHRpbWVzIDFfQiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsImYiLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDXkIiXSxbMiwwLCJDXkIgXFx0aW1lcyBCIl0sWzMsMCwiQyJdLFswLDEsIkEiXSxbMiwxLCJBXFx0aW1lcyBCIl0sWzEsMiwiXFxlcHNpbG9uIl0sWzMsMCwiXFxsYW1iZGEgZiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDEsIlxcbGFtYmRhIGZcXHRpbWVzIDFfQiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsImYiLDJdXQ==&amp;embed&quot; width=&quot;604&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;We show the product morphism of $\lambda f$ with $1_B$ in the commutative diagram below for clarity:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJDXkIiXSxbMSwwLCJDXkIgXFx0aW1lcyBCIl0sWzIsMCwiQiJdLFswLDEsIkEiXSxbMSwxLCJBXFx0aW1lcyBCIl0sWzIsMSwiQiJdLFsxLDAsInBfMSIsMl0sWzEsMiwicF8yIl0sWzMsMCwiXFxsYW1iZGEgZiJdLFs0LDEsIlxcbGFtYmRhIGYgXFx0aW1lcyAxX0IiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNCwzLCJxXzEiXSxbNCw1LCJxXzIiLDJdLFs1LDIsIjFfQiIsMl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJDXkIiXSxbMSwwLCJDXkIgXFx0aW1lcyBCIl0sWzIsMCwiQiJdLFswLDEsIkEiXSxbMSwxLCJBXFx0aW1lcyBCIl0sWzIsMSwiQiJdLFsxLDAsInBfMSIsMl0sWzEsMiwicF8yIl0sWzMsMCwiXFxsYW1iZGEgZiJdLFs0LDEsIlxcbGFtYmRhIGYgXFx0aW1lcyAxX0IiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNCwzLCJxXzEiXSxbNCw1LCJxXzIiLDJdLFs1LDIsIjFfQiIsMl1d&amp;embed&quot; width=&quot;476&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;The uniqueness of $\lambda f$ and $1_B$, and the uniqueness of product morphisms imply that $\lambda f \times 1_B$ is also unique.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 7&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;
Suppose we are in $\textbf{Set}$ and we have sets $\mathbb{B}$ and $\mathbb{C}$. The set of all functions from $\mathbb{B}$ to $\mathbb{C}$ given by
$$
\mathbb{C}^\mathbb{B} = \\\{f \ |\  f: \mathbb{B} \rightarrow \mathbb{C}\\\}
$$
together with the function $\epsilon: \mathbb{C}^\mathbb{B} \rightarrow \mathbb{C}$ given by 
$$
\epsilon(f, b) = f(b)
$$
is the exponential object $\mathbb{C}^\mathbb{B}$.
&lt;&#x2F;p&gt;
&lt;p&gt;
Suppose we have a function $g: A \times B \rightarrow C$. Then, the transpose of $g$ can be given by $\lambda g(a)(b) = g(a, b)$. This construction uniquely (up to a unique isomorphism) characterizes the exponential set of $\mathbb{B}$ and $\mathbb{C}$.
&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 8.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Similar to our earlier example, suppose we are in the category of types $\mathcal{T}$ and we have types &lt;code&gt;B&lt;&#x2F;code&gt; and &lt;code&gt;C&lt;&#x2F;code&gt;. Then, the function type &lt;code&gt;B -&amp;gt; C&lt;&#x2F;code&gt; together with a function &lt;code&gt;eval&#x27; :: (B -&amp;gt; C, B) -&amp;gt; C&lt;&#x2F;code&gt; (recall that &lt;code&gt;(A, B)&lt;&#x2F;code&gt; is the product of types &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;) given by &lt;code&gt;eval&#x27; (f, b) = f b&lt;&#x2F;code&gt; is the exponential object $\mathtt{C}^\mathtt{B}$. That means that given a function of &lt;code&gt;g :: (A, B) -&amp;gt; C&lt;&#x2F;code&gt;, we can define a new function &lt;code&gt;gT :: A -&amp;gt; B -&amp;gt; C&lt;&#x2F;code&gt; given by &lt;code&gt;gT a = \b -&amp;gt; g (a, b)&lt;&#x2F;code&gt; so that &lt;code&gt;g (a, b) == (eval&#x27; . (prod&#x27; gT id)) (a, b)&lt;&#x2F;code&gt;. You should notice that &lt;code&gt;gT&lt;&#x2F;code&gt; is the &lt;strong&gt;curried&lt;&#x2F;strong&gt; equivalent of &lt;code&gt;g&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Char -&amp;gt; String is the exponential String^Char
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;eval&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char -&amp;gt; String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; String
&lt;&#x2F;span&gt;&lt;span&gt;eval&amp;#39; (f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; f s
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- g repeats a character some number of times
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; String
&lt;&#x2F;span&gt;&lt;span&gt;g (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;g (i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; c &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; g (i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- id is the identity function (for all types)
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- id x = x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- gT is the transpose of g
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;gT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Int -&amp;gt; Char -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span&gt;gT i c &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; g (i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;#39;a&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; g (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b)                       &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;aaaaa&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; gT a b                         &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;aaaaa&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (eval&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; (prod&amp;#39; gT id)) (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b) &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;aaaaa&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;We have seen some examples of universal properties which show that these properties are not unique to a particular category, but instead can be described in any arbitrary category. The formal definition of a universal property is not exactly necessary for understanding later sections, but is good to know. We define universal properties and connect them to products and exponentials in the &lt;a href=&quot;https:&#x2F;&#x2F;yongqi.foo&#x2F;blog&#x2F;posts&#x2F;monads&#x2F;#appuniversalproperty&quot;&gt;appendix&lt;&#x2F;a&gt;. Perhaps the most pertinent to our discussion is the fact that universal properties like products and exponentials can be described on any particular category, including categories with categories as objects.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;natural-transformations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#natural-transformations&quot; aria-label=&quot;Anchor link for: natural-transformations&quot;&gt;Natural Transformations&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;In categories, sometimes morphisms do not depend in an essential way on the particular objects they relate. For example, our definition of the projection function on products &lt;code&gt;fst&#x27;&lt;&#x2F;code&gt; and &lt;code&gt;snd&#x27;&lt;&#x2F;code&gt; operate on the pair &lt;code&gt;(Int, Char)&lt;&#x2F;code&gt;, but these functions can operate on a pair of &lt;strong&gt;any&lt;&#x2F;strong&gt; two types &lt;code&gt;a&lt;&#x2F;code&gt; and &lt;code&gt;b&lt;&#x2F;code&gt; and be defined identically. These are the polymorphic functions &lt;code&gt;fst :: (a, b) -&amp;gt; a&lt;&#x2F;code&gt; and &lt;code&gt;snd :: (a, b) -&amp;gt; b&lt;&#x2F;code&gt; which can be described as a family or collection of morphisms, one of each for every product type &lt;code&gt;(A, B)&lt;&#x2F;code&gt;. Such a family is known as a &lt;strong&gt;natural transformation&lt;&#x2F;strong&gt;, which we will define in this section, and we shall also give some intuition of why we can describe natural transformations as being morphisms between functors.&lt;&#x2F;p&gt;
&lt;p&gt;
Suppose in $\textbf{Set}$ we have objects $\mathbb{A}$, $\mathbb{B}$ and their product $\mathbb{A} \times \mathbb{B}$.
The swap function $\text{swap}_{\mathbb{A}, \mathbb{B}}(a, b) = (b, a)$ maps $\mathbb{A} \times \mathbb{B}$ to $\mathbb{B} \times \mathbb{A}$.
Notice that for &lt;b&gt;any&lt;&#x2F;b&gt; objects $\mathbb{C}$ and $\mathbb{D}$ there is also its own swap function $\text{swap}_{\mathbb{C}, \mathbb{D}}: \mathbb{C}\times \mathbb{D} \to \mathbb{D} \times \mathbb{C}$ defined as the more generic $\text{swap}(c, d) = (d, c)$. The swap function does not depend on the particular objects it swaps, since it is defined in the same way for any pair of objects. Such a definition allows swap to preserve composition. For any functions $f: \mathbb{A} \rightarrow \mathbb{C}$ and $g: \mathbb{B} \rightarrow \mathbb{D}$, the following diagram commutes:
&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJcXG1hdGhiYntBfSBcXHRpbWVzIFxcbWF0aGJie0J9Il0sWzIsMCwiXFxtYXRoYmJ7Qn0gXFx0aW1lcyBcXG1hdGhiYntBfSJdLFswLDEsIlxcbWF0aGJie0N9XFx0aW1lcyBcXG1hdGhiYntEfSJdLFsyLDEsIlxcbWF0aGJie0R9IFxcdGltZXMgXFxtYXRoYmJ7Q30iXSxbMCwxLCJcXHRleHR7c3dhcH1fe1xcbWF0aGJie0F9LCBcXG1hdGhiYntCfX0iXSxbMCwyLCJmXFx0aW1lcyBnIiwyXSxbMSwzLCJnXFx0aW1lcyBmIl0sWzIsMywiXFx0ZXh0e3N3YXB9X3tcXG1hdGhiYntDfSwgXFxtYXRoYmJ7RH19IiwyXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJcXG1hdGhiYntBfSBcXHRpbWVzIFxcbWF0aGJie0J9Il0sWzIsMCwiXFxtYXRoYmJ7Qn0gXFx0aW1lcyBcXG1hdGhiYntBfSJdLFswLDEsIlxcbWF0aGJie0N9XFx0aW1lcyBcXG1hdGhiYntEfSJdLFsyLDEsIlxcbWF0aGJie0R9IFxcdGltZXMgXFxtYXRoYmJ7Q30iXSxbMCwxLCJcXHRleHR7c3dhcH1fe1xcbWF0aGJie0F9LCBcXG1hdGhiYntCfX0iXSxbMCwyLCJmXFx0aW1lcyBnIiwyXSxbMSwzLCJnXFx0aW1lcyBmIl0sWzIsMywiXFx0ZXh0e3N3YXB9X3tcXG1hdGhiYntDfSwgXFxtYXRoYmJ7RH19IiwyXV0=&amp;embed&quot; width=&quot;472&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;As we can see, swapping does not depend on the objects it acts on. As such, we can define swap as an entire collection of functions, one for each product. Since this collection preserves composition of morphisms, we can now begin to build some intuition on such collections as morphisms between functors.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 7 (Product Category).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;For a category $\mathcal{C}$, the &lt;strong&gt;product category&lt;&#x2F;strong&gt; $\mathcal{C} \times \mathcal{C}$ has:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;for all objects $a, b \in \text{ob}(\mathcal{C})$, object $(a, b) \in \text{ob}(\mathcal{C} \times \mathcal{C})$&lt;&#x2F;li&gt;
&lt;li&gt;for all morphisms $f, g \in \text{mor}(\mathcal{C})$, morphism $(f, g) \in \text{mor}(\mathcal{C}\times \mathcal{C})$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;where composition of morphisms is defined componentwise.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;This definition of product categories generalizes to a product of two categories, and is indeed a construction of the product of two objects (categories) in $\textbf{Cat}$.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Now we suppose $\mathcal{C}$ has products. Then there is a product functor $P: \mathcal{C} \times \mathcal{C} \rightarrow \mathcal{C}$ given by $P(A, B) = A \times B$ for objects $(A, B)$ and $P(f, g) = f \times g$ for morphisms $(f, g)$, and a swapped product functor $S: \mathcal{C} \times \mathcal{C} \rightarrow \mathcal{C}$ given by $S(A, B) = B \times A$ and $S(f, g) = g \times f$. We can now see that for every morphism $(f: A \rightarrow C, g: B \rightarrow D)$ in $\mathcal{C} \times \mathcal{C}$ the following diagram commutes in $\mathcal{C}$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJQKEEsIEIpIl0sWzIsMCwiUyhBLCBCKSJdLFswLDEsIlAoQywgRCkiXSxbMiwxLCJTKEMsIEQpIl0sWzAsMSwiXFx0ZXh0e3N3YXB9X3tBLCBCfSJdLFswLDIsIntQKGYsIGcpfSIsMl0sWzEsMywie1MoZixnKX0iXSxbMiwzLCJcXHRleHR7c3dhcH1fe0MsRH0iLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJQKEEsIEIpIl0sWzIsMCwiUyhBLCBCKSJdLFswLDEsIlAoQywgRCkiXSxbMiwxLCJTKEMsIEQpIl0sWzAsMSwiXFx0ZXh0e3N3YXB9X3tBLCBCfSJdLFswLDIsIntQKGYsIGcpfSIsMl0sWzEsMywie1MoZixnKX0iXSxbMiwzLCJcXHRleHR7c3dhcH1fe0MsRH0iLDJdXQ==&amp;embed&quot; width=&quot;530&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;This generalization of swap as a family of morphisms between the images of two functors that preserve functoriality of $P$ and $S$ is precisely a &lt;strong&gt;natural transformation&lt;&#x2F;strong&gt; from $P$ to $S$, which we shall define as the following:&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 8 (Natural Transformation).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have categories $\mathcal{C}$ and $\mathcal{D}$ and a parallel pair of functors $F: \mathcal{C} \rightarrow \mathcal{D}$ and $G: \mathcal{C} \rightarrow \mathcal{D}$. A &lt;strong&gt;natural transformation&lt;&#x2F;strong&gt; $\alpha: F \Rightarrow G$ is a family of morphisms (forming the &lt;strong&gt;components&lt;&#x2F;strong&gt; of $\alpha$) $\alpha_C:F(C)\rightarrow G(C)$ for all $C \in \text{ob}(\mathcal{C})$, such that for all morphisms $f: A \rightarrow B$ in $\mathcal{C}$ the following diagram commutes, or by saying that the family of morphisms $\alpha_C$ is &lt;strong&gt;natural&lt;&#x2F;strong&gt; in $C$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJGKEEpIl0sWzEsMCwiRyhBKSJdLFswLDEsIkYoQikiXSxbMSwxLCJHKEIpIl0sWzAsMSwiXFxhbHBoYV9BIl0sWzAsMiwie0YoZil9IiwyXSxbMSwzLCJ7RyhmKX0iXSxbMiwzLCJcXGFscGhhX0IiLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJGKEEpIl0sWzEsMCwiRyhBKSJdLFswLDEsIkYoQikiXSxbMSwxLCJHKEIpIl0sWzAsMSwiXFxhbHBoYV9BIl0sWzAsMiwie0YoZil9IiwyXSxbMSwzLCJ7RyhmKX0iXSxbMiwzLCJcXGFscGhhX0IiLDJdXQ==&amp;embed&quot; width=&quot;326&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Essentially, natural transformations are functoriality-preserving maps between parallel functors.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;A natural transformation $\alpha$ with components $\alpha_a$, $\alpha_b$ and $\alpha_c$ can be depicted with the following diagram.&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTMsWzEsMCwiQSJdLFsyLDAsIkIiXSxbMywwXSxbMSwxXSxbNSwxXSxbMiwyLCJDIl0sWzUsMiwiRyhBKSJdLFs2LDIsIkcoQikiXSxbMCw0XSxbNiw0LCJHKEMpIl0sWzAsNSwiRihBKSJdLFsxLDUsIkYoQikiXSxbMSw3LCJGKEMpIl0sWzAsMSwiZiJdLFswLDUsImdcXGNpcmMgZiIsMl0sWzEsNSwiZyJdLFsyLDQsIkciLDAseyJjdXJ2ZSI6LTEsImxldmVsIjoyfV0sWzMsOCwiRiIsMix7ImN1cnZlIjoxLCJsZXZlbCI6Mn1dLFs2LDcsIkcoZikiXSxbNiw5LCJHKGdcXGNpcmMgZikiXSxbNyw5LCJHKGcpIl0sWzEwLDYsIlxcYWxwaGFfQSIsMCx7ImN1cnZlIjotMSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzEwLDExLCJGKGYpIl0sWzEwLDEyLCJGKGdcXGNpcmMgZikiLDJdLFsxMSw3LCJcXGFscGhhX2IiLDAseyJjdXJ2ZSI6LTEsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxMSwxMiwiRihnKSJdLFsxMiw5LCJcXGFscGhhX2MiLDAseyJjdXJ2ZSI6LTEsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTMsWzEsMCwiQSJdLFsyLDAsIkIiXSxbMywwXSxbMSwxXSxbNSwxXSxbMiwyLCJDIl0sWzUsMiwiRyhBKSJdLFs2LDIsIkcoQikiXSxbMCw0XSxbNiw0LCJHKEMpIl0sWzAsNSwiRihBKSJdLFsxLDUsIkYoQikiXSxbMSw3LCJGKEMpIl0sWzAsMSwiZiJdLFswLDUsImdcXGNpcmMgZiIsMl0sWzEsNSwiZyJdLFsyLDQsIkciLDAseyJjdXJ2ZSI6LTEsImxldmVsIjoyfV0sWzMsOCwiRiIsMix7ImN1cnZlIjoxLCJsZXZlbCI6Mn1dLFs2LDcsIkcoZikiXSxbNiw5LCJHKGdcXGNpcmMgZikiXSxbNyw5LCJHKGcpIl0sWzEwLDYsIlxcYWxwaGFfQSIsMCx7ImN1cnZlIjotMSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzEwLDExLCJGKGYpIl0sWzEwLDEyLCJGKGdcXGNpcmMgZikiLDJdLFsxMSw3LCJcXGFscGhhX2IiLDAseyJjdXJ2ZSI6LTEsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxMSwxMiwiRihnKSJdLFsxMiw5LCJcXGFscGhhX2MiLDAseyJjdXJ2ZSI6LTEsInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==&amp;embed&quot; width=&quot;784&quot; height=&quot;872&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;composition-of-natural-transformations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#composition-of-natural-transformations&quot; aria-label=&quot;Anchor link for: composition-of-natural-transformations&quot;&gt;Composition of Natural Transformations&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Natural transformations can be composed in multiple ways, many of which are pertinent to our discussion. The simplest among them, which is used to define the other forms of composition, is known as &lt;strong&gt;vertical composition&lt;&#x2F;strong&gt;, which is composed componentwose.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 9 (Vertical Composition).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have categories $\mathcal{C}$ and $\mathcal{D}$ and parallel functors $F, G, H: \mathcal{C} \to \mathcal{D}$ with natural transformations $\alpha: F \Rightarrow G$ and $\beta: G \Rightarrow H$.   Then the &lt;strong&gt;vertical composition&lt;&#x2F;strong&gt; of $\alpha$ and $\beta$ denoted $\beta \circ \alpha: F \Rightarrow H$ is composition done component-wise: i.e. $(\beta \circ \alpha)_X = \beta_X \circ \alpha_X$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMywwLCJGKFgpIl0sWzQsMCwiRihZKSJdLFswLDEsIlgiXSxbMSwxLCJZIl0sWzMsMSwiRyhYKSJdLFs0LDEsIkcoWSkiXSxbMywyLCJIKFgpIl0sWzQsMiwiSChZKSJdLFs1LDEsIiAiXSxbMCwxLCJGKGYpIl0sWzAsNCwiXFxhbHBoYV9YIiwyXSxbMCw2LCIoXFxiZXRhXFxjaXJjXFxhbHBoYSlfWCIsMix7ImN1cnZlIjozfV0sWzEsNSwiXFxhbHBoYV9ZIl0sWzEsNywiKFxcYmV0YVxcY2lyY1xcYWxwaGEpX1kiLDAseyJjdXJ2ZSI6LTN9XSxbMiwzLCJmIl0sWzQsNiwiXFxiZXRhX1giLDJdLFs0LDUsIkcoZikiXSxbNSw3LCJcXGJldGFfWSJdLFs2LDcsIkgoZikiLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMywwLCJGKFgpIl0sWzQsMCwiRihZKSJdLFswLDEsIlgiXSxbMSwxLCJZIl0sWzMsMSwiRyhYKSJdLFs0LDEsIkcoWSkiXSxbMywyLCJIKFgpIl0sWzQsMiwiSChZKSJdLFs1LDEsIiAiXSxbMCwxLCJGKGYpIl0sWzAsNCwiXFxhbHBoYV9YIiwyXSxbMCw2LCIoXFxiZXRhXFxjaXJjXFxhbHBoYSlfWCIsMix7ImN1cnZlIjozfV0sWzEsNSwiXFxhbHBoYV9ZIl0sWzEsNywiKFxcYmV0YVxcY2lyY1xcYWxwaGEpX1kiLDAseyJjdXJ2ZSI6LTN9XSxbMiwzLCJmIl0sWzQsNiwiXFxiZXRhX1giLDJdLFs0LDUsIkcoZikiXSxbNSw3LCJcXGJldGFfWSJdLFs2LDcsIkgoZikiLDJdXQ==&amp;embed&quot; width=&quot;648&quot; height=&quot;332&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Or depicted as a globular diagram:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMSwwLCJGIl0sWzQsMCwiRiJdLFswLDEsIlxcbWF0aGNhbHtDfSJdLFsyLDEsIlxcbWF0aGNhbHtEfSJdLFszLDEsIlxcbWF0aGNhbHtDfSJdLFs1LDEsIlxcbWF0aGNhbHtEfSJdLFsxLDIsIkgiXSxbNCwyLCJIIl0sWzEsMSwiRyJdLFsxLDcsIlxcYmV0YVxcY2lyY1xcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsyLDMsIiIsMCx7ImN1cnZlIjotNH1dLFsyLDMsIiIsMix7ImN1cnZlIjo0fV0sWzQsNSwiIiwwLHsiY3VydmUiOi00fV0sWzQsNSwiIiwyLHsiY3VydmUiOjR9XSxbMCw4LCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbOCw2LCJcXGJldGEiLDIseyJsZXZlbCI6Mn1dLFsyLDgsIiIsMSx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbOCwzXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMSwwLCJGIl0sWzQsMCwiRiJdLFswLDEsIlxcbWF0aGNhbHtDfSJdLFsyLDEsIlxcbWF0aGNhbHtEfSJdLFszLDEsIlxcbWF0aGNhbHtDfSJdLFs1LDEsIlxcbWF0aGNhbHtEfSJdLFsxLDIsIkgiXSxbNCwyLCJIIl0sWzEsMSwiRyJdLFsxLDcsIlxcYmV0YVxcY2lyY1xcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsyLDMsIiIsMCx7ImN1cnZlIjotNH1dLFsyLDMsIiIsMix7ImN1cnZlIjo0fV0sWzQsNSwiIiwwLHsiY3VydmUiOi00fV0sWzQsNSwiIiwyLHsiY3VydmUiOjR9XSxbMCw4LCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbOCw2LCJcXGJldGEiLDIseyJsZXZlbCI6Mn1dLFsyLDgsIiIsMSx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbOCwzXV0=&amp;embed&quot; width=&quot;616&quot; height=&quot;332&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
Vertical composition is associative and unital; the identity natural transformation on a functor $F$ is given by $(1_F)_X = 1_{F(X)}$ and is natural in $X$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTQsWzEsMCwiRiJdLFs0LDAsIkYiXSxbNywwLCJGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiRyJdLFsyLDEsIlxcbWF0aGNhbHtEfSJdLFszLDEsIlxcbWF0aGNhbHtDfSJdLFs0LDEsIkciXSxbNSwxLCJcXG1hdGhjYWx7RH0iXSxbNiwxLCJcXG1hdGhjYWx7Q30iXSxbOCwxLCJcXG1hdGhjYWx7RH0iXSxbMSwyLCJHIl0sWzQsMiwiRyJdLFs3LDIsIkciXSxbMCw0LCIxX0YiLDIseyJsZXZlbCI6Mn1dLFsxLDcsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsyLDEzLCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbMyw1LCIiLDIseyJjdXJ2ZSI6NH1dLFszLDUsIiIsMCx7ImN1cnZlIjotNH1dLFs0LDExLCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbNiw4LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNiw4LCIiLDIseyJjdXJ2ZSI6NH1dLFs3LDEyLCIxX0ciLDIseyJsZXZlbCI6Mn1dLFs5LDEwLCIiLDAseyJjdXJ2ZSI6LTR9XSxbOSwxMCwiIiwyLHsiY3VydmUiOjR9XSxbMyw0LCIiLDEseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzQsNV0sWzYsNywiIiwxLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs3LDhdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTQsWzEsMCwiRiJdLFs0LDAsIkYiXSxbNywwLCJGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiRyJdLFsyLDEsIlxcbWF0aGNhbHtEfSJdLFszLDEsIlxcbWF0aGNhbHtDfSJdLFs0LDEsIkciXSxbNSwxLCJcXG1hdGhjYWx7RH0iXSxbNiwxLCJcXG1hdGhjYWx7Q30iXSxbOCwxLCJcXG1hdGhjYWx7RH0iXSxbMSwyLCJHIl0sWzQsMiwiRyJdLFs3LDIsIkciXSxbMCw0LCIxX0YiLDIseyJsZXZlbCI6Mn1dLFsxLDcsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsyLDEzLCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbMyw1LCIiLDIseyJjdXJ2ZSI6NH1dLFszLDUsIiIsMCx7ImN1cnZlIjotNH1dLFs0LDExLCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbNiw4LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNiw4LCIiLDIseyJjdXJ2ZSI6NH1dLFs3LDEyLCIxX0ciLDIseyJsZXZlbCI6Mn1dLFs5LDEwLCIiLDAseyJjdXJ2ZSI6LTR9XSxbOSwxMCwiIiwyLHsiY3VydmUiOjR9XSxbMyw0LCIiLDEseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzQsNV0sWzYsNywiIiwxLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs3LDhdXQ==&amp;embed&quot; width=&quot;800&quot; height=&quot;292&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;To describe another way of composing natural transformations, we need to define a binary operation between a functor and a natural transformation, known as &lt;strong&gt;whiskering&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 10 (Whiskering).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel functors $F,G: \mathcal{C} \to \mathcal{D}$ and a natural transformation $\alpha: F \Rightarrow G$, and another functor $H: \mathcal{D} \to \mathcal{E}$. Then, whiskering $\alpha$ with $H$, denoted $H\alpha$, is the resulting natural transformation $H\alpha: H\circ F \Rightarrow H \circ G$ and $(H\alpha)_X = H(\alpha_X)$ where $\circ$ describes functor composition:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTAsWzEsMCwiWCJdLFsyLDAsIlkiXSxbMCwxLCJGKFgpIl0sWzEsMSwiRihZKSJdLFsyLDEsIkgoRihYKSkiXSxbMywxLCJIKEYoWSkpIl0sWzAsMiwiRyhYKSJdLFsxLDIsIkcoWSkiXSxbMiwyLCJIKEcoWCkpIl0sWzMsMiwiSChHKFkpKSJdLFswLDEsImYiXSxbMiwzLCJGKGYpIl0sWzIsNiwiXFxhbHBoYV9YIiwyXSxbMyw3LCJcXGFscGhhX1kiXSxbNCw4LCIoSFxcYWxwaGEpX1giLDJdLFs0LDUsIkgoRihmKSkiXSxbNSw5LCIoSFxcYWxwaGEpX1kiXSxbNiw3LCJHKGYpIiwyXSxbOCw5LCJIKEcoZikpIiwyXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTAsWzEsMCwiWCJdLFsyLDAsIlkiXSxbMCwxLCJGKFgpIl0sWzEsMSwiRihZKSJdLFsyLDEsIkgoRihYKSkiXSxbMywxLCJIKEYoWSkpIl0sWzAsMiwiRyhYKSJdLFsxLDIsIkcoWSkiXSxbMiwyLCJIKEcoWCkpIl0sWzMsMiwiSChHKFkpKSJdLFswLDEsImYiXSxbMiwzLCJGKGYpIl0sWzIsNiwiXFxhbHBoYV9YIiwyXSxbMyw3LCJcXGFscGhhX1kiXSxbNCw4LCIoSFxcYWxwaGEpX1giLDJdLFs0LDUsIkgoRihmKSkiXSxbNSw5LCIoSFxcYWxwaGEpX1kiXSxbNiw3LCJHKGYpIiwyXSxbOCw5LCJIKEcoZikpIiwyXV0=&amp;embed&quot; width=&quot;515&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Depicted as a globular diagram:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMSwwLCJGIl0sWzUsMCwiSFxcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzIsMSwiXFxtYXRoY2Fse0R9Il0sWzMsMSwiXFxtYXRoY2Fse0V9Il0sWzQsMSwiXFxtYXRoY2Fse0N9Il0sWzYsMSwiXFxtYXRoY2Fse0V9Il0sWzEsMiwiRyJdLFs1LDIsIkhcXGNpcmMgRyJdLFswLDcsIlxcYWxwaGEiLDAseyJsZXZlbCI6Mn1dLFsxLDgsIkhcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMiwzLCIiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCIiLDIseyJjdXJ2ZSI6NH1dLFszLDQsIkgiXSxbNSw2LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNSw2LCIiLDIseyJjdXJ2ZSI6NH1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMSwwLCJGIl0sWzUsMCwiSFxcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzIsMSwiXFxtYXRoY2Fse0R9Il0sWzMsMSwiXFxtYXRoY2Fse0V9Il0sWzQsMSwiXFxtYXRoY2Fse0N9Il0sWzYsMSwiXFxtYXRoY2Fse0V9Il0sWzEsMiwiRyJdLFs1LDIsIkhcXGNpcmMgRyJdLFswLDcsIlxcYWxwaGEiLDAseyJsZXZlbCI6Mn1dLFsxLDgsIkhcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMiwzLCIiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCIiLDIseyJjdXJ2ZSI6NH1dLFszLDQsIkgiXSxbNSw2LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNSw2LCIiLDIseyJjdXJ2ZSI6NH1dXQ==&amp;embed&quot; width=&quot;703&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
Alternatively if we have a functor $F: \mathcal{C} \to \mathcal{D}$ and parallel functors $G,H:\mathcal{D} \to \mathcal{E}$ with natural transformation $\alpha: G \Rightarrow H$ then we get the natural transformation $\alpha F: (G \circ F) \Rightarrow (H \circ F)$ where $(\alpha F)_X = \alpha_{F(X)}$:
&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMSwwLCJYIl0sWzIsMCwiWSJdLFswLDEsIkYoWCkiXSxbMSwxLCJGKFkpIl0sWzIsMSwiRyhGKFgpKSJdLFszLDEsIkcoRihZKSkiXSxbMiwyLCJIKEYoWCkpIl0sWzMsMiwiSChGKFkpKSJdLFswLDEsImYiXSxbMiwzLCJGKGYpIl0sWzQsNiwieyhcXGFscGhhIEYpX1h9IiwyXSxbNCw1LCJHKEYoZikpIl0sWzUsNywieyhcXGFscGhhIEYpX1l9Il0sWzYsNywiSChGKGYpKSIsMl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMSwwLCJYIl0sWzIsMCwiWSJdLFswLDEsIkYoWCkiXSxbMSwxLCJGKFkpIl0sWzIsMSwiRyhGKFgpKSJdLFszLDEsIkcoRihZKSkiXSxbMiwyLCJIKEYoWCkpIl0sWzMsMiwiSChGKFkpKSJdLFswLDEsImYiXSxbMiwzLCJGKGYpIl0sWzQsNiwieyhcXGFscGhhIEYpX1h9IiwyXSxbNCw1LCJHKEYoZikpIl0sWzUsNywieyhcXGFscGhhIEYpX1l9Il0sWzYsNywiSChGKGYpKSIsMl1d&amp;embed&quot; width=&quot;515&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;And as a globular diagram:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMiwwLCJHIl0sWzUsMCwiR1xcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiXFxtYXRoY2Fse0R9Il0sWzMsMSwiXFxtYXRoY2Fse0V9Il0sWzQsMSwiXFxtYXRoY2Fse0N9Il0sWzYsMSwiXFxtYXRoY2Fse0V9Il0sWzIsMiwiSCJdLFs1LDIsIkhcXGNpcmMgRiJdLFswLDcsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsxLDgsIlxcYWxwaGEgRiIsMCx7ImxldmVsIjoyfV0sWzIsMywiRiJdLFszLDQsIiIsMCx7ImN1cnZlIjotNH1dLFszLDQsIiIsMix7ImN1cnZlIjo0fV0sWzUsNiwiIiwwLHsiY3VydmUiOi00fV0sWzUsNiwiIiwyLHsiY3VydmUiOjR9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMiwwLCJHIl0sWzUsMCwiR1xcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiXFxtYXRoY2Fse0R9Il0sWzMsMSwiXFxtYXRoY2Fse0V9Il0sWzQsMSwiXFxtYXRoY2Fse0N9Il0sWzYsMSwiXFxtYXRoY2Fse0V9Il0sWzIsMiwiSCJdLFs1LDIsIkhcXGNpcmMgRiJdLFswLDcsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsxLDgsIlxcYWxwaGEgRiIsMCx7ImxldmVsIjoyfV0sWzIsMywiRiJdLFszLDQsIiIsMCx7ImN1cnZlIjotNH1dLFszLDQsIiIsMix7ImN1cnZlIjo0fV0sWzUsNiwiIiwwLHsiY3VydmUiOi00fV0sWzUsNiwiIiwyLHsiY3VydmUiOjR9XV0=&amp;embed&quot; width=&quot;703&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Whiskering allows us to define &lt;strong&gt;horizontal composition&lt;&#x2F;strong&gt; succinctly.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 11 (Horizontal Composition).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel functors $F, G: \mathcal{C} \to \mathcal{D}$ and $H, K: \mathcal{D} \to \mathcal{E}$, and two natural transformations $\alpha: F \Rightarrow G$ and $\beta: H \Rightarrow K$. The &lt;strong&gt;horizontal composition&lt;&#x2F;strong&gt; of $\alpha$ and $\beta$, denoted $\beta * \alpha: H \circ F \Rightarrow K \circ G$, is given by $\beta * \alpha = \beta G \circ H\alpha = K\alpha \circ \beta F$. This is most easily shown with a globular diagram:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiRiJdLFszLDAsIkgiXSxbNiwwLCJIXFxjaXJjIEYiXSxbMCwxLCJcXG1hdGhjYWx7Q30iXSxbMiwxLCJcXG1hdGhjYWx7RH0iXSxbNCwxLCJcXG1hdGhjYWx7RX0iXSxbNSwxLCJcXG1hdGhjYWx7Q30iXSxbNywxLCJcXG1hdGhjYWx7RX0iXSxbMSwyLCJHIl0sWzMsMiwiSyJdLFs2LDIsIksgXFxjaXJjIEciXSxbMCw4LCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbMSw5LCJcXGJldGEiLDAseyJsZXZlbCI6Mn1dLFsyLDEwLCJcXGJldGEgKiBcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMyw0LCIiLDAseyJjdXJ2ZSI6LTR9XSxbMyw0LCIiLDIseyJjdXJ2ZSI6NH1dLFs0LDUsIiIsMCx7ImN1cnZlIjotNH1dLFs0LDUsIiIsMix7ImN1cnZlIjo0fV0sWzYsNywiIiwwLHsiY3VydmUiOi00fV0sWzYsNywiIiwyLHsiY3VydmUiOjR9XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiRiJdLFszLDAsIkgiXSxbNiwwLCJIXFxjaXJjIEYiXSxbMCwxLCJcXG1hdGhjYWx7Q30iXSxbMiwxLCJcXG1hdGhjYWx7RH0iXSxbNCwxLCJcXG1hdGhjYWx7RX0iXSxbNSwxLCJcXG1hdGhjYWx7Q30iXSxbNywxLCJcXG1hdGhjYWx7RX0iXSxbMSwyLCJHIl0sWzMsMiwiSyJdLFs2LDIsIksgXFxjaXJjIEciXSxbMCw4LCJcXGFscGhhIiwyLHsibGV2ZWwiOjJ9XSxbMSw5LCJcXGJldGEiLDAseyJsZXZlbCI6Mn1dLFsyLDEwLCJcXGJldGEgKiBcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMyw0LCIiLDAseyJjdXJ2ZSI6LTR9XSxbMyw0LCIiLDIseyJjdXJ2ZSI6NH1dLFs0LDUsIiIsMCx7ImN1cnZlIjotNH1dLFs0LDUsIiIsMix7ImN1cnZlIjo0fV0sWzYsNywiIiwwLHsiY3VydmUiOi00fV0sWzYsNywiIiwyLHsiY3VydmUiOjR9XV0=&amp;embed&quot; width=&quot;801&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Alternatively, with the following commutative diagrams:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzEsMCwiSyhGKFgpKSJdLFswLDEsIkgoRihYKSkiXSxbMSwxLCJIKEcoWCkpIl0sWzIsMSwiSyhHKFgpKSJdLFszLDEsIkgoRihYKSkiXSxbNCwxLCJLKEcoWCkpIl0sWzAsMiwiSChGKFkpKSJdLFsxLDIsIkgoRyhZKSkiXSxbMiwyLCJLKEcoWSkpIl0sWzMsMiwiSChGKFkpKSJdLFs0LDIsIksoRyhZKSkiXSxbMSwzLCJLKEYoWSkpIl0sWzAsMywiKEtcXGFscGhhKV9YIl0sWzEsNiwiSChGKGYpKSIsMl0sWzEsMiwiKEhcXGFscGhhKV9YIl0sWzEsMCwiKFxcYmV0YSBGKV9YIl0sWzIsNywiSChHKGYpKSIsMl0sWzIsMywiKFxcYmV0YSBHKV9YIl0sWzMsOCwiSyhHKGYpKSJdLFs0LDUsIihcXGJldGEgKiBcXGFscGhhKV9YIl0sWzQsOSwiSChGKGYpKSJdLFs1LDEwLCJLKEcoZikpIl0sWzYsNywiKEggXFxhbHBoYSlfWSIsMl0sWzYsMTEsIihcXGJldGEgRilfWSIsMl0sWzcsOCwiKFxcYmV0YSBHKV9ZIiwyXSxbOSwxMCwiKFxcYmV0YSAqIFxcYWxwaGEpX1kiLDJdLFsxMSw4LCIoS1xcYWxwaGEpX1kiLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzEsMCwiSyhGKFgpKSJdLFswLDEsIkgoRihYKSkiXSxbMSwxLCJIKEcoWCkpIl0sWzIsMSwiSyhHKFgpKSJdLFszLDEsIkgoRihYKSkiXSxbNCwxLCJLKEcoWCkpIl0sWzAsMiwiSChGKFkpKSJdLFsxLDIsIkgoRyhZKSkiXSxbMiwyLCJLKEcoWSkpIl0sWzMsMiwiSChGKFkpKSJdLFs0LDIsIksoRyhZKSkiXSxbMSwzLCJLKEYoWSkpIl0sWzAsMywiKEtcXGFscGhhKV9YIl0sWzEsNiwiSChGKGYpKSIsMl0sWzEsMiwiKEhcXGFscGhhKV9YIl0sWzEsMCwiKFxcYmV0YSBGKV9YIl0sWzIsNywiSChHKGYpKSIsMl0sWzIsMywiKFxcYmV0YSBHKV9YIl0sWzMsOCwiSyhHKGYpKSJdLFs0LDUsIihcXGJldGEgKiBcXGFscGhhKV9YIl0sWzQsOSwiSChGKGYpKSJdLFs1LDEwLCJLKEcoZikpIl0sWzYsNywiKEggXFxhbHBoYSlfWSIsMl0sWzYsMTEsIihcXGJldGEgRilfWSIsMl0sWzcsOCwiKFxcYmV0YSBHKV9ZIiwyXSxbOSwxMCwiKFxcYmV0YSAqIFxcYWxwaGEpX1kiLDJdLFsxMSw4LCIoS1xcYWxwaGEpX1kiLDJdXQ==&amp;embed&quot; width=&quot;723&quot; height=&quot;350&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;The following globular diagrams help us understand the correspondence of horizontal composition with vertical composition and whiskering:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTAsWzEsMCwiSFxcY2lyYyBGIl0sWzQsMCwiSFxcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiSFxcY2lyYyBHIl0sWzIsMSwiXFxtYXRoY2Fse0V9Il0sWzMsMSwiXFxtYXRoY2Fse0N9Il0sWzQsMSwiS1xcY2lyYyBGIl0sWzUsMSwiXFxtYXRoY2Fse0V9Il0sWzEsMiwiS1xcY2lyYyBHIl0sWzQsMiwiS1xcY2lyYyBHIl0sWzAsMywiSFxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsxLDYsIlxcYmV0YSBGIiwwLHsibGV2ZWwiOjJ9XSxbMiw0LCIiLDAseyJjdXJ2ZSI6LTR9XSxbMiw0LCIiLDIseyJjdXJ2ZSI6NH1dLFszLDgsIlxcYmV0YSBHIiwyLHsibGV2ZWwiOjJ9XSxbNSw3LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNSw3LCIiLDIseyJjdXJ2ZSI6NH1dLFs2LDksIktcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMiwzLCIiLDEseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzMsNF0sWzYsN10sWzUsNiwiIiwxLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTAsWzEsMCwiSFxcY2lyYyBGIl0sWzQsMCwiSFxcY2lyYyBGIl0sWzAsMSwiXFxtYXRoY2Fse0N9Il0sWzEsMSwiSFxcY2lyYyBHIl0sWzIsMSwiXFxtYXRoY2Fse0V9Il0sWzMsMSwiXFxtYXRoY2Fse0N9Il0sWzQsMSwiS1xcY2lyYyBGIl0sWzUsMSwiXFxtYXRoY2Fse0V9Il0sWzEsMiwiS1xcY2lyYyBHIl0sWzQsMiwiS1xcY2lyYyBHIl0sWzAsMywiSFxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFsxLDYsIlxcYmV0YSBGIiwwLHsibGV2ZWwiOjJ9XSxbMiw0LCIiLDAseyJjdXJ2ZSI6LTR9XSxbMiw0LCIiLDIseyJjdXJ2ZSI6NH1dLFszLDgsIlxcYmV0YSBHIiwyLHsibGV2ZWwiOjJ9XSxbNSw3LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNSw3LCIiLDIseyJjdXJ2ZSI6NH1dLFs2LDksIktcXGFscGhhIiwwLHsibGV2ZWwiOjJ9XSxbMiwzLCIiLDEseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzMsNF0sWzYsN10sWzUsNiwiIiwxLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==&amp;embed&quot; width=&quot;654&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
Horizontal composition is also associative and unital. However, take note that the identity, unlike with vertical composition, is in general, not the identity natural transformation on any functor $F$ i.e. $1_F$ which contains the family of morphisms $(1_F)_X = 1_{F(X)}$; if we have $F: \mathcal{C} \to \mathcal{D}$ (parallel to itself) and its identity natural transformation $1_F: F \Rightarrow F$ horizontally composed with a natural transformation $\beta: G \Rightarrow H$ between two parallel functors $G, H: \mathcal{D} \to \mathcal{E}$, we get $\beta F: G \circ F \Rightarrow H \circ F$, which is simply whiskering:
&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiRiJdLFszLDAsIkciXSxbNiwwLCJHXFxjaXJjIEYiXSxbMCwxLCJcXG1hdGhjYWx7Q30iXSxbMiwxLCJcXG1hdGhjYWx7RH0iXSxbNCwxLCJcXG1hdGhjYWx7RX0iXSxbNSwxLCJcXG1hdGhjYWx7Q30iXSxbNywxLCJcXG1hdGhjYWx7RX0iXSxbMSwyLCJGIl0sWzMsMiwiSCJdLFs2LDIsIkggXFxjaXJjIEYiXSxbMCw4LCJ7MV9GfSIsMix7ImxldmVsIjoyfV0sWzEsOSwiXFxiZXRhIiwwLHsibGV2ZWwiOjJ9XSxbMiwxMCwiXFxiZXRhIEYiLDAseyJsZXZlbCI6Mn1dLFszLDQsIiIsMCx7ImN1cnZlIjotNH1dLFszLDQsIiIsMix7ImN1cnZlIjo0fV0sWzQsNSwiIiwwLHsiY3VydmUiOi00fV0sWzQsNSwiIiwyLHsiY3VydmUiOjR9XSxbNiw3LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNiw3LCIiLDIseyJjdXJ2ZSI6NH1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiRiJdLFszLDAsIkciXSxbNiwwLCJHXFxjaXJjIEYiXSxbMCwxLCJcXG1hdGhjYWx7Q30iXSxbMiwxLCJcXG1hdGhjYWx7RH0iXSxbNCwxLCJcXG1hdGhjYWx7RX0iXSxbNSwxLCJcXG1hdGhjYWx7Q30iXSxbNywxLCJcXG1hdGhjYWx7RX0iXSxbMSwyLCJGIl0sWzMsMiwiSCJdLFs2LDIsIkggXFxjaXJjIEYiXSxbMCw4LCJ7MV9GfSIsMix7ImxldmVsIjoyfV0sWzEsOSwiXFxiZXRhIiwwLHsibGV2ZWwiOjJ9XSxbMiwxMCwiXFxiZXRhIEYiLDAseyJsZXZlbCI6Mn1dLFszLDQsIiIsMCx7ImN1cnZlIjotNH1dLFszLDQsIiIsMix7ImN1cnZlIjo0fV0sWzQsNSwiIiwwLHsiY3VydmUiOi00fV0sWzQsNSwiIiwyLHsiY3VydmUiOjR9XSxbNiw3LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNiw3LCIiLDIseyJjdXJ2ZSI6NH1dXQ==&amp;embed&quot; width=&quot;891&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzEsMCwiSChGKFgpKSJdLFswLDEsIkcoRihYKSkiXSxbMSwxLCJHKEYoWCkpIl0sWzIsMSwiSChGKFgpKSJdLFszLDEsIkcoRihYKSkiXSxbNCwxLCJIKEYoWCkpIl0sWzAsMiwiRyhGKFkpKSJdLFsxLDIsIkcoRihZKSkiXSxbMiwyLCJIKEYoWSkpIl0sWzMsMiwiRyhGKFkpKSJdLFs0LDIsIkgoRihZKSkiXSxbMSwzLCJIKEYoWSkpIl0sWzAsMywiKEgxX0YpX1giXSxbMSw2LCJHKEYoZikpIiwyXSxbMSwyLCIoRzFfRilfWCJdLFsxLDAsIihcXGJldGEgRilfWCJdLFsyLDcsIkcoRihmKSkiLDJdLFsyLDMsIihcXGJldGEgRilfWCJdLFszLDgsIkgoRihmKSkiXSxbNCw1LCIoXFxiZXRhICogMV9GKV9YIl0sWzQsOSwiRyhGKGYpKSJdLFs1LDEwLCJIKEYoZikpIl0sWzYsNywiKEcgMV9GKV9ZIiwyXSxbNiwxMSwiKFxcYmV0YSBGKV9ZIiwyXSxbNyw4LCIoXFxiZXRhIEYpX1kiLDJdLFs5LDEwLCIoXFxiZXRhICogMV9GKV9ZIiwyXSxbMTEsOCwiKEgxX0YpX1kiLDJdXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzEsMCwiSChGKFgpKSJdLFswLDEsIkcoRihYKSkiXSxbMSwxLCJHKEYoWCkpIl0sWzIsMSwiSChGKFgpKSJdLFszLDEsIkcoRihYKSkiXSxbNCwxLCJIKEYoWCkpIl0sWzAsMiwiRyhGKFkpKSJdLFsxLDIsIkcoRihZKSkiXSxbMiwyLCJIKEYoWSkpIl0sWzMsMiwiRyhGKFkpKSJdLFs0LDIsIkgoRihZKSkiXSxbMSwzLCJIKEYoWSkpIl0sWzAsMywiKEgxX0YpX1giXSxbMSw2LCJHKEYoZikpIiwyXSxbMSwyLCIoRzFfRilfWCJdLFsxLDAsIihcXGJldGEgRilfWCJdLFsyLDcsIkcoRihmKSkiLDJdLFsyLDMsIihcXGJldGEgRilfWCJdLFszLDgsIkgoRihmKSkiXSxbNCw1LCIoXFxiZXRhICogMV9GKV9YIl0sWzQsOSwiRyhGKGYpKSJdLFs1LDEwLCJIKEYoZikpIl0sWzYsNywiKEcgMV9GKV9ZIiwyXSxbNiwxMSwiKFxcYmV0YSBGKV9ZIiwyXSxbNyw4LCIoXFxiZXRhIEYpX1kiLDJdLFs5LDEwLCIoXFxiZXRhICogMV9GKV9ZIiwyXSxbMTEsOCwiKEgxX0YpX1kiLDJdXQ==&amp;embed&quot; width=&quot;715&quot; height=&quot;400&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
Instead, the identity of horizontal composition is the identity natural transformation of the identity functor of a category. Given category $\mathcal{C}$, its identity functor $1_\mathcal{C}$ maps all objects and morphisms to themselves, i.e. $1_\mathcal{C}(X) = X$ and $1_\mathcal{C}(f) = f$ for all objects $X$ and morphisms $f$ in $\mathcal{C}$ (this is the identity morphism of an object $\mathcal{C}$ in the category of categories). The identity natural transformation of $1_\mathcal{C}$, i.e. $1_{1_\mathcal{C}}$ simply contains the identity morphisms in $\mathcal{C}$, i.e. $(1_{1_\mathcal{C}})_X = 1_{1_\mathcal{C}(X)} = 1_X$ for each object $X$ in $\mathcal{C}$. This is indeed the identity for horizontal composition. If we have $\beta: F \Rightarrow G$ where $F,G: \mathcal{C} \to \mathcal{D}$, then $\beta * 1_{1_\mathcal{C}}: F \circ 1_\mathcal{C} \Rightarrow G \circ 1_\mathcal{C}$ will be defined as $\beta * 1_{1_\mathcal{C}} = \beta 1_\mathcal{C} \circ F1_{1_\mathcal{C}}$. As per the definition of whiskering, we have $(\beta 1_\mathcal{C})_X = \beta_{1_\mathcal{C}(X)} = \beta_X$ so $\beta 1_\mathcal{C} = \beta$, and $(F 1_{1_\mathcal{C}})_X = F((1_{1_\mathcal{C}})_X) = F(1_{1_\mathcal{C}(X)}) = F(1_X) = 1_{F(X)} = (1_F)_X$ so $F 1_{1_\mathcal{C}}$ is the identity natural transformation $1_F$, which we know is an identity for vertical composition with $\beta$, i.e. $\beta * 1_{1_\mathcal{C}} = \beta \circ 1_F = \beta$:
&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiMV9cXG1hdGhjYWx7Q30iXSxbMywwLCJGIl0sWzYsMCwiRlxcY2lyYyAxX1xcbWF0aGNhbHtDfSJdLFswLDEsIlxcbWF0aGNhbHtDfSJdLFsyLDEsIlxcbWF0aGNhbHtDfSJdLFs0LDEsIlxcbWF0aGNhbHtEfSJdLFs1LDEsIlxcbWF0aGNhbHtDfSJdLFs3LDEsIlxcbWF0aGNhbHtEfSJdLFsxLDIsIjFfXFxtYXRoY2Fse0N9Il0sWzMsMiwiRyJdLFs2LDIsIkdcXGNpcmMgMV9cXG1hdGhjYWx7Q30iXSxbMCw4LCJ7MV97MV9cXG1hdGhjYWx7Q319fSIsMix7ImxldmVsIjoyfV0sWzEsOSwiXFxiZXRhIiwwLHsibGV2ZWwiOjJ9XSxbMiwxMCwiXFxiZXRhICogMV97MXtcXG1hdGhjYWx7Q319fSIsMCx7ImxldmVsIjoyfV0sWzMsNCwiIiwwLHsiY3VydmUiOi00fV0sWzMsNCwiIiwyLHsiY3VydmUiOjR9XSxbNCw1LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNCw1LCIiLDIseyJjdXJ2ZSI6NH1dLFs2LDcsIiIsMCx7ImN1cnZlIjotNH1dLFs2LDcsIiIsMix7ImN1cnZlIjo0fV1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTEsWzEsMCwiMV9cXG1hdGhjYWx7Q30iXSxbMywwLCJGIl0sWzYsMCwiRlxcY2lyYyAxX1xcbWF0aGNhbHtDfSJdLFswLDEsIlxcbWF0aGNhbHtDfSJdLFsyLDEsIlxcbWF0aGNhbHtDfSJdLFs0LDEsIlxcbWF0aGNhbHtEfSJdLFs1LDEsIlxcbWF0aGNhbHtDfSJdLFs3LDEsIlxcbWF0aGNhbHtEfSJdLFsxLDIsIjFfXFxtYXRoY2Fse0N9Il0sWzMsMiwiRyJdLFs2LDIsIkdcXGNpcmMgMV9cXG1hdGhjYWx7Q30iXSxbMCw4LCJ7MV97MV9cXG1hdGhjYWx7Q319fSIsMix7ImxldmVsIjoyfV0sWzEsOSwiXFxiZXRhIiwwLHsibGV2ZWwiOjJ9XSxbMiwxMCwiXFxiZXRhICogMV97MXtcXG1hdGhjYWx7Q319fSIsMCx7ImxldmVsIjoyfV0sWzMsNCwiIiwwLHsiY3VydmUiOi00fV0sWzMsNCwiIiwyLHsiY3VydmUiOjR9XSxbNCw1LCIiLDAseyJjdXJ2ZSI6LTR9XSxbNCw1LCIiLDIseyJjdXJ2ZSI6NH1dLFs2LDcsIiIsMCx7ImN1cnZlIjotNH1dLFs2LDcsIiIsMix7ImN1cnZlIjo0fV1d&amp;embed&quot; width=&quot;893&quot; height=&quot;302&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;With similar arguments you can show that $1_{1_\mathcal{D}} * \beta = \beta$.&lt;&#x2F;p&gt;
&lt;p&gt;As stated earlier, the identity natural transformation on the identity functor on a category is precisely the family of identity morphisms in a category. In our category of types $\mathcal{T}$, $(1_{1_\mathcal{T}})_A = 1_A$, which is the identity function &lt;code&gt;id :: a -&amp;gt; a&lt;&#x2F;code&gt; given by &lt;code&gt;id x = x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;correspondence-with-polymorphic-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#correspondence-with-polymorphic-functions&quot; aria-label=&quot;Anchor link for: correspondence-with-polymorphic-functions&quot;&gt;Correspondence with Polymorphic Functions&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 9.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have two functorial type constructors: non-empty lists, and boxes.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- NonEmpty List type
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;NEL&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; a (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;NEL&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- For printing NELs, not important
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Show &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt; Show&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;NEL &lt;&#x2F;span&gt;&lt;span&gt;a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;  show ls &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; show &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; toList ls &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    toList (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;    toList (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; a t) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; toList t
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Box type
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;deriving &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Show
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Functor instances
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Functor NEL where
&lt;&#x2F;span&gt;&lt;span&gt;  fmap f (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f a
&lt;&#x2F;span&gt;&lt;span&gt;  fmap f (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; a t) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; (f a) (fmap f t)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Functor Box where
&lt;&#x2F;span&gt;&lt;span&gt;  fmap f (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Letting $F: \mathcal{T} \to \mathcal{T}$ be the &lt;code&gt;NEL&lt;&#x2F;code&gt; functor, and $G: \mathcal{T} \to \mathcal{T}$ be the &lt;code&gt;Box&lt;&#x2F;code&gt; functor, we have the following commutative diagrams describing the action of $F$ and $G$ in the category of types $\mathcal{T}$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiRihBKSJdLFsyLDAsIkcoQSkiXSxbMCwxLCJCIl0sWzEsMSwiRihCKSJdLFsyLDEsIkcoQikiXSxbMCwzLCJmIl0sWzEsNCwiRihmKSJdLFsyLDUsIkcoZikiXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiRihBKSJdLFsyLDAsIkcoQSkiXSxbMCwxLCJCIl0sWzEsMSwiRihCKSJdLFsyLDEsIkcoQikiXSxbMCwzLCJmIl0sWzEsNCwiRihmKSJdLFsyLDUsIkcoZikiXV0=&amp;embed&quot; width=&quot;354&quot; height=&quot;234&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Now let us define a function &lt;code&gt;toBox&lt;&#x2F;code&gt; that receives a nonempty list of integers and puts its first element in a box:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;toBox &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: NEL Int -&amp;gt; Box Int
&lt;&#x2F;span&gt;&lt;span&gt;toBox (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;toBox (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; a t) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see that this function is a single morphism from &lt;code&gt;NEL Int&lt;&#x2F;code&gt; to &lt;code&gt;Box Int&lt;&#x2F;code&gt;. Clearly, this definition should not be restricted to the &lt;code&gt;Int&lt;&#x2F;code&gt; type argument since the same definition applies to all types &lt;code&gt;a&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;toBox &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: NEL &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; Box &lt;&#x2F;span&gt;&lt;span&gt;a
&lt;&#x2F;span&gt;&lt;span&gt;toBox (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;toBox (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt; a t) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Box&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows &lt;code&gt;toBox&lt;&#x2F;code&gt; to be natural in all types &lt;code&gt;a&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiRihBKSJdLFsyLDAsIkcoQSkiXSxbMCwxLCJCIl0sWzEsMSwiRihCKSJdLFsyLDEsIkcoQikiXSxbMCwzLCJmIl0sWzEsNCwiRihmKSJdLFsxLDIsIntcXG1hdGh0dHt0b0JveH1fQX0iXSxbMiw1LCJHKGYpIl0sWzQsNSwie1xcbWF0aHR0e3RvQm94fV9CfSIsMl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNixbMCwwLCJBIl0sWzEsMCwiRihBKSJdLFsyLDAsIkcoQSkiXSxbMCwxLCJCIl0sWzEsMSwiRihCKSJdLFsyLDEsIkcoQikiXSxbMCwzLCJmIl0sWzEsNCwiRihmKSJdLFsxLDIsIntcXG1hdGh0dHt0b0JveH1fQX0iXSxbMiw1LCJHKGYpIl0sWzQsNSwie1xcbWF0aHR0e3RvQm94fV9CfSIsMl1d&amp;embed&quot; width=&quot;354&quot; height=&quot;234&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ls &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;de&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;L &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;f&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fmap length ls         &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- [3,2,1]
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fmap length (toBox ls) &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Box 3
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; toBox &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fmap length ls &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Box 3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Naturality of &lt;code&gt;toBox&lt;&#x2F;code&gt; should be easy to show, since its definition does not depend on what the type &lt;code&gt;a&lt;&#x2F;code&gt; is.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;functor-categories&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#functor-categories&quot; aria-label=&quot;Anchor link for: functor-categories&quot;&gt;Functor Categories&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In fact, functors also assemble into categories. Such a category has functors as objects and natural transformations between them as morphisms.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 12 (Functor Category).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have categories $\mathcal{C}$ and $\mathcal{D}$. The &lt;strong&gt;functor category&lt;&#x2F;strong&gt; $\mathcal{D}^\mathcal{C}$ has as objects, functors $F: \mathcal{C} \rightarrow \mathcal{D}$ and as morphisms, natural transformations $\alpha: F \Rightarrow G$. Composition of morphisms is defined as vertical composition of natural transformations, and the identity morphism of any object $F: \mathcal{C} \to \mathcal{D}$ is its identity natural transformation $1_F$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;To build some intuition for later sections, given category $\mathcal{C}$ we shall define the category of endofunctors of $\mathcal{C}$ to be $\mathcal{C}^\mathcal{C}$, containing all endofunctors $F: \mathcal{C} \to \mathcal{C}$. Notice that the domain and codomain of these functors are equal, so they can be composed with themselves, i.e. since $F \circ F : \mathcal{C} \to \mathcal{C}$ is also an endofunctor of $\mathcal{C}$, so $F \circ F$ is also an object in $\mathcal{C}^\mathcal{C}$. We also know that functor composition is associative, i.e. $((F \circ F) \circ F)(X) = (F \circ (F \circ F))(X) = F(F(F(X)))$ for all objects (and morphisms) $X$ of $\mathcal{C}$, so we shall denote $F \circ F$ and $F \circ F \circ F$ as $F^2$ and $F^3$ respectively (all of these functors are objects in $\mathcal{C}^\mathcal{C}$).&lt;&#x2F;p&gt;
&lt;p&gt;A natural question might be to ask, what is a morphism from $F$ to $F^2$? For example,
we know that functor composition is unital with the identity functor on the (co)domain category, i.e. $1_\mathcal{C} \circ F = F \circ 1_\mathcal{C} = F$, thus with a natural transformation $\alpha: 1_\mathcal{C} \Rightarrow F$, we can construct two natural transformations from $F$ to $F^2$, $F\alpha: F \circ 1_\mathcal{C} \Rightarrow F^2$ and $\alpha F: 1_\mathcal{C} \circ F \Rightarrow F^2$. Notice that $\alpha F \circ \alpha = F\alpha \circ \alpha$:&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzAsMCwiQSJdLFsxLDAsIkYoQSkiXSxbMiwwLCJBIl0sWzMsMCwiRihBKSJdLFs0LDAsIjFfXFxtYXRoY2Fse0N9Il0sWzUsMCwiRiJdLFswLDEsIkIiXSxbMSwxLCJGKEIpIl0sWzIsMSwiRihBKSJdLFszLDEsIkYoRihBKSkiXSxbNCwxLCJGIl0sWzUsMSwiRl4yIl0sWzAsMSwiXFxhbHBoYV9BIl0sWzAsNiwiZiIsMl0sWzEsNywiRihmKSJdLFsyLDMsIlxcYWxwaGFfQSJdLFsyLDgsIlxcYWxwaGFfQSIsMl0sWzMsOSwiRihcXGFscGhhX0EpIl0sWzQsNSwiXFxhbHBoYSIsMCx7ImxldmVsIjoyfV0sWzQsMTAsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFs1LDExLCJcXGFscGhhIEYiLDAseyJsZXZlbCI6Mn1dLFs2LDcsIlxcYWxwaGFfQiJdLFs4LDksIlxcYWxwaGFfe0YoQSl9Il0sWzEwLDExLCJGIFxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsMTIsWzAsMCwiQSJdLFsxLDAsIkYoQSkiXSxbMiwwLCJBIl0sWzMsMCwiRihBKSJdLFs0LDAsIjFfXFxtYXRoY2Fse0N9Il0sWzUsMCwiRiJdLFswLDEsIkIiXSxbMSwxLCJGKEIpIl0sWzIsMSwiRihBKSJdLFszLDEsIkYoRihBKSkiXSxbNCwxLCJGIl0sWzUsMSwiRl4yIl0sWzAsMSwiXFxhbHBoYV9BIl0sWzAsNiwiZiIsMl0sWzEsNywiRihmKSJdLFsyLDMsIlxcYWxwaGFfQSJdLFsyLDgsIlxcYWxwaGFfQSIsMl0sWzMsOSwiRihcXGFscGhhX0EpIl0sWzQsNSwiXFxhbHBoYSIsMCx7ImxldmVsIjoyfV0sWzQsMTAsIlxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dLFs1LDExLCJcXGFscGhhIEYiLDAseyJsZXZlbCI6Mn1dLFs2LDcsIlxcYWxwaGFfQiJdLFs4LDksIlxcYWxwaGFfe0YoQSl9Il0sWzEwLDExLCJGIFxcYWxwaGEiLDIseyJsZXZlbCI6Mn1dXQ==&amp;embed&quot; width=&quot;694&quot; height=&quot;234&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 10.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have, as a natural transformation in $\mathcal{T}$, the polymorphic function &lt;code&gt;pairList&lt;&#x2F;code&gt; which receives an object and puts two of them in a list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;pairList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;pairList a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; a]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Letting $L$ be our list functor, we let $\alpha L$ be &lt;code&gt;pairList&lt;&#x2F;code&gt; itself (applied to objects of type &lt;code&gt;[a]&lt;&#x2F;code&gt;) and $L \alpha$ be &lt;code&gt;fmap pairList&lt;&#x2F;code&gt;. Then, we can see that $\alpha L \circ \alpha = L \alpha \circ \alpha$, i.e. &lt;code&gt;fmap pairList . pairList&lt;&#x2F;code&gt; and &lt;code&gt;pairList . pairList&lt;&#x2F;code&gt; is the same polymorphic function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; fmap pairList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; pairList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- [[2,2],[2,2]]
&lt;&#x2F;span&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; pairList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; pairList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- [[2,2],[2,2]]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Since we are in the category of (endo)functors, another question might be to ask, what is an isomorphism of functors? By definition, this would be two natural transformations that when composes, gives the identity functor. This is known as a &lt;strong&gt;natural isomorphism&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 13 (Natural Isomorphism).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have functors $F, G: \mathcal{C} \to \mathcal{D}$. The natural transformation $\alpha: F \Rightarrow G$ is a &lt;strong&gt;natural isomorphism&lt;&#x2F;strong&gt; if the two conditions are met (the two conditions are equal):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Each component $\alpha_X: F(X) \to G(X)$ in $\mathcal{D}$ is an isomorphism.&lt;&#x2F;li&gt;
&lt;li&gt;There exists $\beta:G \Rightarrow F$ such that $\beta \circ \alpha = 1_F$ and $\alpha \circ \beta = 1_G$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If there exists a natural isomorphism between $F$ and $G$, they are said to be naturally isomorphic, i.e. $F \cong G$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Let us show that the two conditions are equal.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Lemma 4.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel functors $F, G: \mathcal{C} \to \mathcal{D}$ and a natural transformation $\alpha: F \Rightarrow G$. If each component $\alpha_X: F(X) \to G(X)$ is an isomorphism, then there exists $\beta: G \Rightarrow F$ such that $\beta \circ \alpha = 1_F$ and $\alpha \circ \beta = 1_G$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof.&lt;&#x2F;strong&gt; Since each component $\alpha_X: F(X) \to G(X)$ is an isomorphism, each has an isomorphism $\beta_X: G(X) \to F(X)$ such that $\alpha_X\circ\beta_X = 1_{G(X)}$ and $\beta_X\circ\alpha_X = 1_{F(X)}$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJGKFgpIl0sWzEsMCwiRyhYKSJdLFswLDEsIkYoWSkiXSxbMSwxLCJHKFkpIl0sWzAsMSwiXFxhbHBoYV9YIiwwLHsib2Zmc2V0IjotMX1dLFswLDIsIkYoZikiLDJdLFsxLDMsIkcoZikiXSxbMSwwLCJcXGJldGFfWCIsMCx7Im9mZnNldCI6LTF9XSxbMiwzLCJcXGFscGhhX1kiLDAseyJvZmZzZXQiOi0xfV0sWzMsMiwiXFxiZXRhX1kiLDAseyJvZmZzZXQiOi0xfV1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNCxbMCwwLCJGKFgpIl0sWzEsMCwiRyhYKSJdLFswLDEsIkYoWSkiXSxbMSwxLCJHKFkpIl0sWzAsMSwiXFxhbHBoYV9YIiwwLHsib2Zmc2V0IjotMX1dLFswLDIsIkYoZikiLDJdLFsxLDMsIkcoZikiXSxbMSwwLCJcXGJldGFfWCIsMCx7Im9mZnNldCI6LTF9XSxbMiwzLCJcXGFscGhhX1kiLDAseyJvZmZzZXQiOi0xfV0sWzMsMiwiXFxiZXRhX1kiLDAseyJvZmZzZXQiOi0xfV1d&amp;embed&quot; width=&quot;332&quot; height=&quot;304&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
Clearly, these morphisms assemble into a natural transformation $\beta: G \Rightarrow F$. Composition of these natural transformations show $(\alpha \circ \beta)_X = \alpha_X \circ \beta_X = 1_{G(X)} = (1_G)_X$, and $(\beta \circ \alpha)_X = \beta_X \circ \alpha_X = 1_{F(X)} = (1_F)_X$.
&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Lemma 5.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel functors $F, G: \mathcal{C} \to \mathcal{D}$ and a natural transformation $\alpha: F \Rightarrow G$. If there exists $\beta: G \Rightarrow F$ such that $\beta \circ \alpha = 1_F$ and $\alpha \circ \beta = 1_G$, then each component $\alpha_X: F(X) \to G(X)$ is an isomorphism.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;
&lt;strong&gt;Proof&lt;&#x2F;strong&gt;.
    Clearly, we have, for each $X$, $(\beta \circ \alpha)_X = (1_F)_X$ so $\beta_X \circ \alpha_X = 1_{F(X)}$, and $(\alpha \circ \beta)_X = (1_G)_X$ so $\alpha_X \circ \beta_X = 1_{G(X)}$, which shows that each component $\alpha_X$ is an isomorphism.
&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem 6.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel functors $F, G: \mathcal{C} \to \mathcal{D}$ and a natural transformation $\alpha: F \Rightarrow G$. Each component $\alpha_X: F(X) \to G(X)$ is an isomorphism if and only if there exists $\beta: G \Rightarrow F$ such that $\beta \circ \alpha = 1_F$ and $\alpha \circ \beta = 1_G$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. By Lemma 4 and Lemma 5.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 11.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;In the category of types $\mathcal{T}$, &lt;code&gt;((A, B), C)&lt;&#x2F;code&gt; is isomorphic to &lt;code&gt;(A, (B, C))&lt;&#x2F;code&gt; for all types &lt;code&gt;A&lt;&#x2F;code&gt;, &lt;code&gt;B&lt;&#x2F;code&gt; and &lt;code&gt;C&lt;&#x2F;code&gt;, given by the following functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- isomorphism
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;tripleIso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a, (b, c)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; ((a, b), c)
&lt;&#x2F;span&gt;&lt;span&gt;tripleIso (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; ((a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- inverse of isomorphism
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;tripleIso&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; ((a, b), c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a, (b, c))
&lt;&#x2F;span&gt;&lt;span&gt;tripleIso&amp;#39; ((a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This isomorphism is natural in &lt;code&gt;A&lt;&#x2F;code&gt;, &lt;code&gt;B&lt;&#x2F;code&gt; and &lt;code&gt;C&lt;&#x2F;code&gt;. This can be expressed as the natural isomorphism &lt;code&gt;tripleIso&lt;&#x2F;code&gt; between two functors $F: \mathcal{T} \times \mathcal{T} \times \mathcal{T} \to \mathcal{T}$ and $G: \mathcal{T} \times \mathcal{T} \times \mathcal{T} \to \mathcal{T}$
given by $F(\mathtt{A}, \mathtt{B}, \mathtt{C}) = $ &lt;code&gt;(A, (B, C))&lt;&#x2F;code&gt; and $G(\mathtt{A}, \mathtt{B}, \mathtt{C}) = $ &lt;code&gt;((A, B), C)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;By this point, we should have built up enough intuition behind describing a natural family of morphisms as a natural transformation between functors, and how they can be seen as morphisms between functors. Correspondingly, a natural family of isomorphisms in a category is a natural isomorphism, and they can likewise be seen as an isomorphism of functors. Natural isomorphisms also help us to loosen our notion of &quot;equivalence&quot; of categories. In the category of (small) categories, we get an isomorphism of categories $F: \mathcal{C} \to \mathcal{D}$ where there exists a functor $G: \mathcal{D} \to \mathcal{C}$ such that $F \circ G = 1_\mathcal{D}$ and $G \circ F = 1_\mathcal{C}$, in other words, $\mathcal{C} \cong \mathcal{D}$. However, such an isomorphism is too strict to categorize an &quot;equivalence&quot; of categories. Instead, we can define a &lt;strong&gt;natural equivalence&lt;&#x2F;strong&gt; that replaces the equal sign earlier with natural isomorphisms, i.e. $\mathcal{C}$ and $\mathcal{D}$ are &lt;strong&gt;naturally equivalent&lt;&#x2F;strong&gt; if there exists functors $F: \mathcal{C} \to \mathcal{D}$ and $G: \mathcal{D} \to \mathcal{C}$ such that $F \circ G \cong 1_\mathcal{D}$ and $G \circ F \cong 1_\mathcal{C}$. The natural equivalence of these categories is denoted $\mathcal{C} \simeq \mathcal{D}$.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;monoids&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#monoids&quot; aria-label=&quot;Anchor link for: monoids&quot;&gt;Monoids&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Monoids are also algebraic structures, which is usually defined as such:&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#6&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 14 (Monoid (Algebraic)).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;monoid&lt;&#x2F;strong&gt; $(M, \cdot, e)$ is a set $M$ endowed with a binary operator $\cdot: M \times M \to M$ and an identity element $e \in M$ subject to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Unity&lt;&#x2F;strong&gt;. $e\cdot x = x \cdot e = x$ for all $x \in M$.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Associativity&lt;&#x2F;strong&gt;. $(x \cdot y) \cdot z = x \cdot (y \cdot z)$ for all $x,y,z\in M$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 12.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$(\mathbb{N}, +, 0)$ and $(\mathbb{N}, \times, 1)$ are monoids.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;We would, as always, like to generalize the notion of monoids to other categories. Let us attempt to generalize the monoid $(\mathbb{N}, +, 0)$. We can see that a monoid has a set $\mathbb{N}$, which is an object in $\textbf{Set}$. We also have a binary operation $\cdot$, which we can model as a function on the cartesian product of $\mathbb{N}$ with itself, to $\mathbb{N}$, i.e. $\cdot: \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ given by $\cdot(x, y) = x + y$. The identity element can be seen as a function $\epsilon: I \to \mathbb{N}$ from any singleton set to $\mathbb{N}$. For example, let the singleton be $I = {1}$. Then we can define $\epsilon:I \to \mathbb{N}$ be given by $\epsilon(x) = 0$.&lt;&#x2F;p&gt;
&lt;p&gt;Now, observe the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For all sets $A, B$ and $C$ we can see that $A \times (B \times C)$ and $(A \times B) \times C$ is isomorphic, given by $f(a, (b, c)) = ((a, b), c)$ and $f^{-1}((a, b), c) = (a, (b, c))$. This gives us a natural isomorphism $\alpha_{A,B,C}$ that associates the cartesian product of sets.&lt;&#x2F;li&gt;
&lt;li&gt;For all sets $A$, we can see that $I \times A$ is isomorphic to $A$, given by $f(i, a) = a$ and $f^{-1}(a) = (1, a)$ (recall that 1 is the only element in $I$). This gives us a natural isomorphism $\lambda_A$ that shows an isomorphism between $A$ and $I \times A$.&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, for all sets $A$, we can see that $A \times I$ is isomorphic to $A$, given by $f(a, i) = a$ and $f^{-1}(a) = (a, 1)$. This gives us a natural isomorphism $\rho_A$ that shows an isomorphism between $A$ and $A \times I$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Based on these observations, the following diagrams commute. The first diagram shows that for $a, b, c \in \mathbb{N}$, $a + b \in \mathbb{N}$ and $a + (b + c) = (a + b) + c$, while the second shows that $a + 0 = 0 + a = a$ where $0 \in \mathbb{N}$:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJcXG1hdGhiYntOfSBcXHRpbWVzIChcXG1hdGhiYntOfSBcXHRpbWVzIFxcbWF0aGJie059KSJdLFsxLDAsIihcXG1hdGhiYntOfSBcXHRpbWVzIFxcbWF0aGJie059KSBcXHRpbWVzIFxcbWF0aGJie059Il0sWzIsMCwiXFxtYXRoYmJ7Tn0gXFx0aW1lcyBcXG1hdGhiYntOfSJdLFswLDEsIlxcbWF0aGJie059IFxcdGltZXMgXFxtYXRoYmJ7Tn0iXSxbMiwxLCJcXG1hdGhiYntOfSJdLFswLDIsIklcXHRpbWVzXFxtYXRoYmJ7Tn0iXSxbMSwyLCJcXG1hdGhiYntOfVxcdGltZXNcXG1hdGhiYntOfSJdLFsyLDIsIlxcbWF0aGJie059XFx0aW1lcyBJIl0sWzEsMywiXFxtYXRoYmJ7Tn0iXSxbMCwxLCJ7XFxhbHBoYV97XFxtYXRoYmJ7Tn0sXFxtYXRoYmJ7Tn0sXFxtYXRoYmJ7Tn19fSJdLFswLDMsIjFfXFxtYXRoYmJ7Tn0gXFx0aW1lcyBcXGNkb3QiLDJdLFsxLDIsIlxcY2RvdCBcXHRpbWVzIDFfXFxtYXRoYmJ7Tn0iXSxbMiw0LCJcXGNkb3QiXSxbMyw0LCJcXGNkb3QiLDJdLFs1LDYsIlxcZXBzaWxvblxcdGltZXMgMV9cXG1hdGhiYntOfSJdLFs1LDgsIlxcbGFtYmRhX1xcbWF0aGJie059IiwyXSxbNiw4LCJcXGNkb3QiXSxbNyw2LCIxX1xcbWF0aGJie059XFx0aW1lc1xcZXBzaWxvbiIsMl0sWzcsOCwiXFxyaG9fXFxtYXRoYmJ7Tn0iXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJcXG1hdGhiYntOfSBcXHRpbWVzIChcXG1hdGhiYntOfSBcXHRpbWVzIFxcbWF0aGJie059KSJdLFsxLDAsIihcXG1hdGhiYntOfSBcXHRpbWVzIFxcbWF0aGJie059KSBcXHRpbWVzIFxcbWF0aGJie059Il0sWzIsMCwiXFxtYXRoYmJ7Tn0gXFx0aW1lcyBcXG1hdGhiYntOfSJdLFswLDEsIlxcbWF0aGJie059IFxcdGltZXMgXFxtYXRoYmJ7Tn0iXSxbMiwxLCJcXG1hdGhiYntOfSJdLFswLDIsIklcXHRpbWVzXFxtYXRoYmJ7Tn0iXSxbMSwyLCJcXG1hdGhiYntOfVxcdGltZXNcXG1hdGhiYntOfSJdLFsyLDIsIlxcbWF0aGJie059XFx0aW1lcyBJIl0sWzEsMywiXFxtYXRoYmJ7Tn0iXSxbMCwxLCJ7XFxhbHBoYV97XFxtYXRoYmJ7Tn0sXFxtYXRoYmJ7Tn0sXFxtYXRoYmJ7Tn19fSJdLFswLDMsIjFfXFxtYXRoYmJ7Tn0gXFx0aW1lcyBcXGNkb3QiLDJdLFsxLDIsIlxcY2RvdCBcXHRpbWVzIDFfXFxtYXRoYmJ7Tn0iXSxbMiw0LCJcXGNkb3QiXSxbMyw0LCJcXGNkb3QiLDJdLFs1LDYsIlxcZXBzaWxvblxcdGltZXMgMV9cXG1hdGhiYntOfSJdLFs1LDgsIlxcbGFtYmRhX1xcbWF0aGJie059IiwyXSxbNiw4LCJcXGNkb3QiXSxbNyw2LCIxX1xcbWF0aGJie059XFx0aW1lc1xcZXBzaWxvbiIsMl0sWzcsOCwiXFxyaG9fXFxtYXRoYmJ7Tn0iXV0=&amp;embed&quot; width=&quot;544&quot; height=&quot;460&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Another question to ask is, in what categories do monoids arise? Let us observe that in $\textbf{Set}$, together with the cartesian product $\times$ and a singleton set $I$, the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFx0aW1lcyAoQlxcdGltZXMgKEMgXFx0aW1lcyBEKSkpIl0sWzEsMCwiKEFcXHRpbWVzIEIpXFx0aW1lcyhDXFx0aW1lcyBEKSJdLFsyLDAsIigoQSBcXHRpbWVzIEIpIFxcdGltZXMgQykgXFx0aW1lcyBEIl0sWzAsMSwiQSBcXHRpbWVzICgoQiBcXHRpbWVzIEMpIFxcdGltZXMgRCkiXSxbMiwxLCIoQSBcXHRpbWVzIChCIFxcdGltZXMgQykpXFx0aW1lcyBEIl0sWzAsMiwiQSBcXHRpbWVzIChJIFxcdGltZXMgQikiXSxbMiwyLCIoQSBcXHRpbWVzIEkpXFx0aW1lcyBCIl0sWzEsMywiQSBcXHRpbWVzIEIiXSxbMCwxLCJ7XFxhbHBoYV97QSxCLENcXHRpbWVzIER9fSJdLFswLDMsInsxX0EgXFx0aW1lcyBcXGFscGhhX3tCLEMsRH19IiwyXSxbMSwyLCJ7XFxhbHBoYV97QVxcdGltZXMgQixDLER9fSJdLFszLDQsIntcXGFscGhhX3tBLEJcXHRpbWVzIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9XFx0aW1lcyAxX0R9IiwyXSxbNSw2LCJ7XFxhbHBoYV97QSxJLEJ9fSJdLFs1LDcsIjFfQVxcdGltZXNcXGxhbWJkYV9CIiwyXSxbNiw3LCJcXHJob19BXFx0aW1lcyAxX0IiXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFx0aW1lcyAoQlxcdGltZXMgKEMgXFx0aW1lcyBEKSkpIl0sWzEsMCwiKEFcXHRpbWVzIEIpXFx0aW1lcyhDXFx0aW1lcyBEKSJdLFsyLDAsIigoQSBcXHRpbWVzIEIpIFxcdGltZXMgQykgXFx0aW1lcyBEIl0sWzAsMSwiQSBcXHRpbWVzICgoQiBcXHRpbWVzIEMpIFxcdGltZXMgRCkiXSxbMiwxLCIoQSBcXHRpbWVzIChCIFxcdGltZXMgQykpXFx0aW1lcyBEIl0sWzAsMiwiQSBcXHRpbWVzIChJIFxcdGltZXMgQikiXSxbMiwyLCIoQSBcXHRpbWVzIEkpXFx0aW1lcyBCIl0sWzEsMywiQSBcXHRpbWVzIEIiXSxbMCwxLCJ7XFxhbHBoYV97QSxCLENcXHRpbWVzIER9fSJdLFswLDMsInsxX0EgXFx0aW1lcyBcXGFscGhhX3tCLEMsRH19IiwyXSxbMSwyLCJ7XFxhbHBoYV97QVxcdGltZXMgQixDLER9fSJdLFszLDQsIntcXGFscGhhX3tBLEJcXHRpbWVzIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9XFx0aW1lcyAxX0R9IiwyXSxbNSw2LCJ7XFxhbHBoYV97QSxJLEJ9fSJdLFs1LDcsIjFfQVxcdGltZXNcXGxhbWJkYV9CIiwyXSxbNiw3LCJcXHJob19BXFx0aW1lcyAxX0IiXV0=&amp;embed&quot; width=&quot;847&quot; height=&quot;460&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Let us finally generalize these observations to define &lt;strong&gt;monoids in a monoidal category&lt;&#x2F;strong&gt;. First, we generalize the cartesian product $\times$ to a &lt;strong&gt;monoidal product&lt;&#x2F;strong&gt; $\otimes$ that associate up to natural isomorphisms $\alpha$, $\lambda$ and $\rho$. This gives the definition of a &lt;strong&gt;monoidal category&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 15 (Monoidal Category).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A monoidal category is a category $\mathcal{C}$ equipped with:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A bifunctor $\otimes:\mathcal{C} \times \mathcal{C} \to \mathcal{C}$ known as the &lt;strong&gt;monoidal product&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;An object $I$ in $\mathcal{C}$ known as the &lt;strong&gt;monoidal unit&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Such that the monoidal product is associative and unital up to natural isomorphism, via three natural isomorphisms:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;associator&lt;&#x2F;strong&gt; $\alpha_{A,B,C}: A \otimes (B \otimes C) \cong (A \otimes B) \otimes C$.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;strong&gt;left identity&lt;&#x2F;strong&gt; on $I$, $\lambda_A: I \otimes A \cong A$.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;strong&gt;right identity&lt;&#x2F;strong&gt; on $I$, $\rho_A: A \otimes I \cong A$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This data is subject to the condition that for all objects $A,B,C$ and $D$, the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFxvdGltZXMgKEJcXG90aW1lcyAoQyBcXG90aW1lcyBEKSkpIl0sWzEsMCwiKEFcXG90aW1lcyBCKVxcb3RpbWVzKENcXG90aW1lcyBEKSJdLFsyLDAsIigoQSBcXG90aW1lcyBCKSBcXG90aW1lcyBDKSBcXG90aW1lcyBEIl0sWzAsMSwiQSBcXG90aW1lcyAoKEIgXFxvdGltZXMgQykgXFxvdGltZXMgRCkiXSxbMiwxLCIoQSBcXG90aW1lcyAoQiBcXG90aW1lcyBDKSlcXG90aW1lcyBEIl0sWzAsMiwiQSBcXG90aW1lcyAoSSBcXG90aW1lcyBCKSJdLFsyLDIsIihBIFxcb3RpbWVzIEkpXFxvdGltZXMgQiJdLFsxLDMsIkEgXFxvdGltZXMgQiJdLFswLDEsIntcXGFscGhhX3tBLEIsQ1xcb3RpbWVzIER9fSJdLFswLDMsInsxX0EgXFxvdGltZXMgXFxhbHBoYV97QixDLER9fSIsMl0sWzEsMiwie1xcYWxwaGFfe0FcXG90aW1lcyBCLEMsRH19Il0sWzMsNCwie1xcYWxwaGFfe0EsQlxcb3RpbWVzIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9XFxvdGltZXMgMV9EfSIsMl0sWzUsNiwie1xcYWxwaGFfe0EsSSxCfX0iXSxbNSw3LCIxX0FcXG90aW1lc1xcbGFtYmRhX0IiLDJdLFs2LDcsIlxccmhvX0FcXG90aW1lcyAxX0IiXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFxvdGltZXMgKEJcXG90aW1lcyAoQyBcXG90aW1lcyBEKSkpIl0sWzEsMCwiKEFcXG90aW1lcyBCKVxcb3RpbWVzKENcXG90aW1lcyBEKSJdLFsyLDAsIigoQSBcXG90aW1lcyBCKSBcXG90aW1lcyBDKSBcXG90aW1lcyBEIl0sWzAsMSwiQSBcXG90aW1lcyAoKEIgXFxvdGltZXMgQykgXFxvdGltZXMgRCkiXSxbMiwxLCIoQSBcXG90aW1lcyAoQiBcXG90aW1lcyBDKSlcXG90aW1lcyBEIl0sWzAsMiwiQSBcXG90aW1lcyAoSSBcXG90aW1lcyBCKSJdLFsyLDIsIihBIFxcb3RpbWVzIEkpXFxvdGltZXMgQiJdLFsxLDMsIkEgXFxvdGltZXMgQiJdLFswLDEsIntcXGFscGhhX3tBLEIsQ1xcb3RpbWVzIER9fSJdLFswLDMsInsxX0EgXFxvdGltZXMgXFxhbHBoYV97QixDLER9fSIsMl0sWzEsMiwie1xcYWxwaGFfe0FcXG90aW1lcyBCLEMsRH19Il0sWzMsNCwie1xcYWxwaGFfe0EsQlxcb3RpbWVzIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9XFxvdGltZXMgMV9EfSIsMl0sWzUsNiwie1xcYWxwaGFfe0EsSSxCfX0iXSxbNSw3LCIxX0FcXG90aW1lc1xcbGFtYmRhX0IiLDJdLFs2LDcsIlxccmhvX0FcXG90aW1lcyAxX0IiXV0=&amp;embed&quot; width=&quot;847&quot; height=&quot;460&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;This gives rise to the (most general) definition of a &lt;strong&gt;monoid&lt;&#x2F;strong&gt; in a monoidal category.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 16 (Monoid).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A &lt;strong&gt;monoid&lt;&#x2F;strong&gt; $(M,\mu,\epsilon)$ in a monoidal category $(\mathcal{C}, \otimes, I)$ consists of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;An object $M$ in $\mathcal{C}$.&lt;&#x2F;li&gt;
&lt;li&gt;A morphism for &lt;strong&gt;multiplication&lt;&#x2F;strong&gt; $\mu: M \otimes M \to M$.&lt;&#x2F;li&gt;
&lt;li&gt;A &lt;strong&gt;unit&lt;&#x2F;strong&gt; morphism $\epsilon: I \to M$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;such that the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJNIFxcb3RpbWVzIChNIFxcb3RpbWVzIE0pIl0sWzEsMCwiKE0gXFxvdGltZXMgTSkgXFxvdGltZXMgTSJdLFsyLDAsIk0gXFxvdGltZXMgTSJdLFswLDEsIk0gXFxvdGltZXMgTSJdLFsyLDEsIk0iXSxbMCwyLCJJXFxvdGltZXMgTSJdLFsxLDIsIk0gXFxvdGltZXMgTSJdLFsyLDIsIk0gXFxvdGltZXMgSSJdLFsxLDMsIk0iXSxbMCwxLCJ7XFxhbHBoYV97TSxNLE19fSJdLFswLDMsIjFfTSBcXG90aW1lcyBcXG11IiwyXSxbMSwyLCJcXG11IFxcb3RpbWVzIDFfTSJdLFsyLDQsIlxcbXUiXSxbMyw0LCJcXG11IiwyXSxbNSw2LCJcXGVwc2lsb25cXG90aW1lcyAxX00iXSxbNSw4LCJcXGxhbWJkYV9NIiwyXSxbNiw4LCJcXG11Il0sWzcsNiwiMV9NXFxvdGltZXNcXGVwc2lsb24iLDJdLFs3LDgsIlxccmhvX00iXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJNIFxcb3RpbWVzIChNIFxcb3RpbWVzIE0pIl0sWzEsMCwiKE0gXFxvdGltZXMgTSkgXFxvdGltZXMgTSJdLFsyLDAsIk0gXFxvdGltZXMgTSJdLFswLDEsIk0gXFxvdGltZXMgTSJdLFsyLDEsIk0iXSxbMCwyLCJJXFxvdGltZXMgTSJdLFsxLDIsIk0gXFxvdGltZXMgTSJdLFsyLDIsIk0gXFxvdGltZXMgSSJdLFsxLDMsIk0iXSxbMCwxLCJ7XFxhbHBoYV97TSxNLE19fSJdLFswLDMsIjFfTSBcXG90aW1lcyBcXG11IiwyXSxbMSwyLCJcXG11IFxcb3RpbWVzIDFfTSJdLFsyLDQsIlxcbXUiXSxbMyw0LCJcXG11IiwyXSxbNSw2LCJcXGVwc2lsb25cXG90aW1lcyAxX00iXSxbNSw4LCJcXGxhbWJkYV9NIiwyXSxbNiw4LCJcXG11Il0sWzcsNiwiMV9NXFxvdGltZXNcXGVwc2lsb24iLDJdLFs3LDgsIlxccmhvX00iXV0=&amp;embed&quot; width=&quot;622&quot; height=&quot;460&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;The diagrams given in these two definitions are a generalization of the ones for the monoid $(\mathbb{N}, +, 0)$ replacing $\mathbb{N}$ with $M$, $\times$ with $\otimes$, and $\cdot$ with $\mu$.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 13.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;$(\mathbb{N}, +, e)$ where $+(x, y) = x + y$ and $e(x) = 0$ is a monoid in $(\textbf{Set}, \times, {1})$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 14.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;The unit type &lt;code&gt;()&lt;&#x2F;code&gt; has only one object &lt;code&gt;()&lt;&#x2F;code&gt; inhabiting it. Then, $(\mathcal{T}, \times, \mathtt{()})$ is a monoidal category. Recall the &lt;code&gt;tripleIso&lt;&#x2F;code&gt; natural isomorphism showing associativity, and the &lt;code&gt;prod&#x27;&lt;&#x2F;code&gt; function that creates the product of two functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;tripleIso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a, (b, c)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; ((a, b), c)
&lt;&#x2F;span&gt;&lt;span&gt;tripleIso (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; ((a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; c)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;prod&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a&amp;#39;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;b&amp;#39;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a, b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a&amp;#39;, b&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;prod&amp;#39; f g (x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; y) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (f x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; g y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let us now show an example of what follows from the commutativity of the pentagon diagram:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;#39;b&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tripleIso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tripleIso x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- (((1,&amp;quot;a&amp;quot;),2.0),&amp;#39;b&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; tripleIso id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tripleIso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; id tripleIso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; x
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- (((1,&amp;quot;a&amp;quot;),2.0),&amp;#39;b&amp;#39;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Also, with the natural isomorphisms describing left and right identities:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;leftId &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;, a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a
&lt;&#x2F;span&gt;&lt;span&gt;leftId (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;rightId &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (a, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a
&lt;&#x2F;span&gt;&lt;span&gt;rightId (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The following follows from the commutativity of the triangle:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; id leftId &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- (1,&amp;quot;hello&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; rightId id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tripleIso x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- (1,&amp;quot;hello&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, $(\mathtt{String}, \mathtt{concat&#x27;}, \mathtt{emptyString})$ is a monoid in our monoidal category, where the &lt;code&gt;concat&#x27;&lt;&#x2F;code&gt; function concatenates two strings, and the &lt;code&gt;emptyString&lt;&#x2F;code&gt; function produces the empty string (list) from the unit object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; String
&lt;&#x2F;span&gt;&lt;span&gt;concat&amp;#39; (a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt; b
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;emptyString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; String
&lt;&#x2F;span&gt;&lt;span&gt;emptyString x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;An example of the result of commutativity of the monoid pentagon follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;b&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; concat&amp;#39; id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; tripleIso x &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; id concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; x           &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;An example of the result of the commutativity of the monoid triangle follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (prod&amp;#39; emptyString id) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; leftId (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)                             &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concat&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; prod&amp;#39; id emptyString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;def&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;def&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; rightId (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;def&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;)                            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;def&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A consequence of $(\mathtt{String}, \mathtt{concat&#x27;}, \mathtt{emptyString})$ being a monoid is that folding left or right on a list of strings using &lt;code&gt;++&lt;&#x2F;code&gt; and the empty string as the identity element gives the same result:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; foldl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(++) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;b&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; foldr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(++) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;b&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abc&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;h1 id=&quot;monads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#monads&quot; aria-label=&quot;Anchor link for: monads&quot;&gt;Monads&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;
Monads are incredibly important in functional programming; if you have come this far, this must be the section you&#x27;ve been wanting to read. First, let us recall that, given category $\mathcal{C}$, we can obtain the category of endofunctors of $\mathcal{C}$, denoted $\mathcal{C}^\mathcal{C}$. $(\mathcal{C}^\mathcal{C}, \circ, 1_\mathcal{C})$ is a monoidal category ($\circ$ here represents functor composition). We know that functor composition is associative (i.e. $(F\circ(G\circ H)) = ((F\circ G)\circ H)$) and unital (i.e. $F \circ 1_\mathcal{C} = 1_\mathcal{C} \circ F = F$), and thus we have natural isomorphisms $\alpha_{A,B,C}, \lambda_A$ and $\rho_A$ that are &lt;strong&gt;equalities&lt;&#x2F;strong&gt;, i.e. $\alpha_{A,B,C}: (A\circ(B\circ C)) = ((A\circ B)\circ C)$, $\lambda_A: 1_\mathcal{C} \circ A = A$ and $\rho_A: A \circ 1_\mathcal{C} = A$ with components $(\alpha_{A,B,C})_X=1_{A(B(C(X)))}, (\lambda_A)_X = (\rho_A)_X=1_{A(X)}$. Thus, the commutativity of the pentagon and triangle diagrams for monoidal categories follows immediately:
&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFxjaXJjIChCXFxjaXJjIChDIFxcY2lyYyBEKSkpIl0sWzEsMCwiKEFcXGNpcmMgQilcXGNpcmMoQ1xcY2lyYyBEKSJdLFsyLDAsIigoQSBcXGNpcmMgQikgXFxjaXJjIEMpIFxcY2lyYyBEIl0sWzAsMSwiQSBcXGNpcmMgKChCIFxcY2lyYyBDKSBcXGNpcmMgRCkiXSxbMiwxLCIoQSBcXGNpcmMgKEIgXFxjaXJjIEMpKVxcY2lyYyBEIl0sWzAsMiwiQSBcXGNpcmMgKDFfXFxtYXRoY2Fse0N9IFxcY2lyYyBCKSJdLFsyLDIsIihBIFxcY2lyYyAxX1xcbWF0aGNhbHtDfSlcXGNpcmMgQiJdLFsxLDMsIkEgXFxjaXJjIEIiXSxbMCwxLCJ7XFxhbHBoYV97QSxCLENcXGNpcmMgRH19Il0sWzAsMywiezFfQSAqIFxcYWxwaGFfe0IsQyxEfX0iLDJdLFsxLDIsIntcXGFscGhhX3tBXFxjaXJjIEIsQyxEfX0iXSxbMyw0LCJ7XFxhbHBoYV97QSxCXFxjaXJjIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9ICogMV9EfSIsMl0sWzUsNiwie1xcYWxwaGFfe0EsSSxCfX0iXSxbNSw3LCIxX0EgKlxcbGFtYmRhX0IiLDJdLFs2LDcsIlxccmhvX0EgKiAxX0IiXV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJBXFxjaXJjIChCXFxjaXJjIChDIFxcY2lyYyBEKSkpIl0sWzEsMCwiKEFcXGNpcmMgQilcXGNpcmMoQ1xcY2lyYyBEKSJdLFsyLDAsIigoQSBcXGNpcmMgQikgXFxjaXJjIEMpIFxcY2lyYyBEIl0sWzAsMSwiQSBcXGNpcmMgKChCIFxcY2lyYyBDKSBcXGNpcmMgRCkiXSxbMiwxLCIoQSBcXGNpcmMgKEIgXFxjaXJjIEMpKVxcY2lyYyBEIl0sWzAsMiwiQSBcXGNpcmMgKDFfXFxtYXRoY2Fse0N9IFxcY2lyYyBCKSJdLFsyLDIsIihBIFxcY2lyYyAxX1xcbWF0aGNhbHtDfSlcXGNpcmMgQiJdLFsxLDMsIkEgXFxjaXJjIEIiXSxbMCwxLCJ7XFxhbHBoYV97QSxCLENcXGNpcmMgRH19Il0sWzAsMywiezFfQSAqIFxcYWxwaGFfe0IsQyxEfX0iLDJdLFsxLDIsIntcXGFscGhhX3tBXFxjaXJjIEIsQyxEfX0iXSxbMyw0LCJ7XFxhbHBoYV97QSxCXFxjaXJjIEMsRH19IiwyXSxbNCwyLCJ7XFxhbHBoYV97QSxCLEN9ICogMV9EfSIsMl0sWzUsNiwie1xcYWxwaGFfe0EsSSxCfX0iXSxbNSw3LCIxX0EgKlxcbGFtYmRhX0IiLDJdLFs2LDcsIlxccmhvX0EgKiAxX0IiXV0=&amp;embed&quot; width=&quot;769&quot; height=&quot;430&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;
We make special note of the horizontal composition of natural transformations in the diagrams. For the pentagon diagram, recall that $1_A * \alpha_{B,C,D} = A\alpha_{B,C,D}$. As such, the components $(1_A * \alpha_{B,C,D})_X = (A\alpha_{B,C,D})_X = A((\alpha_{B,C,D})_X) = A(1_{B(C(D(X)))})$. By functoriality of $A$, $A(1_{B(C(D(X)))}) = 1_{A(B(C(D(X))))}$. Similarly, since $\alpha_{A,B,C} * 1_D = \alpha_{A,B,C}D$, $(\alpha_{A,B,C} * 1_D)_X = (\alpha_{A,B,C}D)_X = (\alpha_{A,B,C})_{D(X)} = 1_{A(B(C(D(X))))}$. For the triangle, $(1_A * \lambda_B)_X =(A\lambda_B)_X=A((\lambda_B)_X)=A(1_{B(X)})=1_{A(B(X))} = (\rho_A)_{B(X)} = (\rho_AB)_X =(\rho_A * 1_B)_X$.
&lt;&#x2F;p&gt;
&lt;p&gt;When $\alpha$, $\lambda$ and $\rho$ represent equalities, we have what is known as a &lt;strong&gt;strict monoidal category&lt;&#x2F;strong&gt;. Thus, $\mathcal{C}^\mathcal{C}$ is a strict monoidal category. As such, we shall do away with the symbol for functor composition (like before) since any interpretation of $ABCD$ for functors $A,B,C$ and $D$ is the same functor.&lt;&#x2F;p&gt;
&lt;p&gt;Now let us determine what a monoid in $\mathcal{C}^\mathcal{C}$ will look like. Such a monoid $(M, \mu, \epsilon)$ will have natural transformations $\mu: M^2 \Rightarrow M$ and $\epsilon: 1_\mathcal{C} \Rightarrow M$ where the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJNXjMiXSxbMSwwLCJNXjMiXSxbMiwwLCJNXjIiXSxbMCwxLCJNXjIiXSxbMiwxLCJNIl0sWzAsMiwiMV9cXG1hdGhjYWx7Q31NIl0sWzEsMiwiTV4yIl0sWzIsMiwiTTFfXFxtYXRoY2Fse0N9Il0sWzEsMywiTSJdLFswLDEsIntcXGFscGhhX3tNLE0sTX19Il0sWzAsMywiMV9NICogXFxtdSIsMl0sWzEsMiwiXFxtdSAqIDFfTSJdLFsyLDQsIlxcbXUiXSxbMyw0LCJcXG11IiwyXSxbNSw2LCJcXGVwc2lsb24gKiAxX00iXSxbNSw4LCJcXGxhbWJkYV9NIiwyXSxbNiw4LCJcXG11Il0sWzcsNiwiMV9NICogXFxlcHNpbG9uIiwyXSxbNyw4LCJcXHJob19NIl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOSxbMCwwLCJNXjMiXSxbMSwwLCJNXjMiXSxbMiwwLCJNXjIiXSxbMCwxLCJNXjIiXSxbMiwxLCJNIl0sWzAsMiwiMV9cXG1hdGhjYWx7Q31NIl0sWzEsMiwiTV4yIl0sWzIsMiwiTTFfXFxtYXRoY2Fse0N9Il0sWzEsMywiTSJdLFswLDEsIntcXGFscGhhX3tNLE0sTX19Il0sWzAsMywiMV9NICogXFxtdSIsMl0sWzEsMiwiXFxtdSAqIDFfTSJdLFsyLDQsIlxcbXUiXSxbMyw0LCJcXG11IiwyXSxbNSw2LCJcXGVwc2lsb24gKiAxX00iXSxbNSw4LCJcXGxhbWJkYV9NIiwyXSxbNiw4LCJcXG11Il0sWzcsNiwiMV9NICogXFxlcHNpbG9uIiwyXSxbNyw4LCJcXHJob19NIl1d&amp;embed&quot; width=&quot;332&quot; height=&quot;440&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Observe:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;In the pentagon diagram, $\alpha$ represents an equality, $\mu * 1_M = \mu M$ and $1_M * \mu = M\mu$.&lt;&#x2F;li&gt;
&lt;li&gt;In the triangle, $1_\mathcal{C}M=M1_\mathcal{C} = M$, $\epsilon * 1_M = \epsilon M$, $1_M * \epsilon = M \epsilon$, and $\lambda_M$ and $\rho_M$ represent equalities.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As such, we can collapse each of the two diagrams into a square:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: center; align-items: center; flex-direction: column;&quot;&gt;
  &lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJNXjMiXSxbMSwwLCJNXjIiXSxbMiwwLCJNIl0sWzMsMCwiTV4yIl0sWzAsMSwiTV4yIl0sWzEsMSwiTSJdLFsyLDEsIk1eMiJdLFszLDEsIk0iXSxbMCwxLCJcXG11IE0iXSxbMCw0LCJNXFxtdSIsMl0sWzEsNSwiXFxtdSJdLFsyLDMsIlxcZXBzaWxvbiBNIl0sWzIsNiwiTVxcZXBzaWxvbiIsMl0sWzIsNywiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMyw3LCJcXG11Il0sWzQsNSwiXFxtdSIsMl0sWzYsNywiXFxtdSIsMl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJNXjMiXSxbMSwwLCJNXjIiXSxbMiwwLCJNIl0sWzMsMCwiTV4yIl0sWzAsMSwiTV4yIl0sWzEsMSwiTSJdLFsyLDEsIk1eMiJdLFszLDEsIk0iXSxbMCwxLCJcXG11IE0iXSxbMCw0LCJNXFxtdSIsMl0sWzEsNSwiXFxtdSJdLFsyLDMsIlxcZXBzaWxvbiBNIl0sWzIsNiwiTVxcZXBzaWxvbiIsMl0sWzIsNywiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMyw3LCJcXG11Il0sWzQsNSwiXFxtdSIsMl0sWzYsNywiXFxtdSIsMl1d&amp;embed&quot; width=&quot;420&quot; height=&quot;224&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;

  &lt;p style=&quot;font-size: 0.8em&quot;&gt;&lt;i&gt;Click on quiver logo to view full diagram&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;You might be surprised to know that this is the definition of a &lt;strong&gt;monad&lt;&#x2F;strong&gt; on $\mathcal{C}$. As such, &lt;strong&gt;a monad on $\mathcal{C}$ is a monoid in the category of endofunctors of $\mathcal{C}$&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 17 (Monad).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;A monad $(M, \mu, \epsilon)$ on $\mathcal{C}$ is an endofunctor $M: \mathcal{C} \to \mathcal{C}$ equipped with two natural transformations $\mu:M^2 \Rightarrow M$ and $\epsilon: 1_\mathcal{C} \Rightarrow M$ such that the following diagrams commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJNXjMiXSxbMSwwLCJNXjIiXSxbMiwwLCJNIl0sWzMsMCwiTV4yIl0sWzAsMSwiTV4yIl0sWzEsMSwiTSJdLFsyLDEsIk1eMiJdLFszLDEsIk0iXSxbMCwxLCJcXG11IE0iXSxbMCw0LCJNXFxtdSIsMl0sWzEsNSwiXFxtdSJdLFsyLDMsIlxcZXBzaWxvbiBNIl0sWzIsNiwiTVxcZXBzaWxvbiIsMl0sWzIsNywiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMyw3LCJcXG11Il0sWzQsNSwiXFxtdSIsMl0sWzYsNywiXFxtdSIsMl1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsOCxbMCwwLCJNXjMiXSxbMSwwLCJNXjIiXSxbMiwwLCJNIl0sWzMsMCwiTV4yIl0sWzAsMSwiTV4yIl0sWzEsMSwiTSJdLFsyLDEsIk1eMiJdLFszLDEsIk0iXSxbMCwxLCJcXG11IE0iXSxbMCw0LCJNXFxtdSIsMl0sWzEsNSwiXFxtdSJdLFsyLDMsIlxcZXBzaWxvbiBNIl0sWzIsNiwiTVxcZXBzaWxvbiIsMl0sWzIsNywiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMyw3LCJcXG11Il0sWzQsNSwiXFxtdSIsMl0sWzYsNywiXFxtdSIsMl1d&amp;embed&quot; width=&quot;420&quot; height=&quot;224&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Example 15.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Recall our list functor $L$ that maps types to a list of that type, and lifts functions on types to functions on lists of those types. $L$ is clearly an endofunctor of $\mathcal{T}$, because the list type(s) are also types. As such, let us define the natural transformation &lt;code&gt;concatAll&lt;&#x2F;code&gt; that takes a list of list of types and concatenates its elements together:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span&gt; [[a]] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;concatAll (x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; xs) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt; concatAll xs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Naturality of &lt;code&gt;concatAll&lt;&#x2F;code&gt; should be intuitive. Then, let us define the &lt;code&gt;singleton&lt;&#x2F;code&gt; function that puts an object by itself in a list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;singleton &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;singleton a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, naturality of &lt;code&gt;singleton&lt;&#x2F;code&gt; should be intuitive. With these functions, $(L,$ &lt;code&gt;concatAll&lt;&#x2F;code&gt;, &lt;code&gt;singleton&lt;&#x2F;code&gt;$)$ is a monad. The consequence of this is that &lt;code&gt;concatAll . concatAll&lt;&#x2F;code&gt; and &lt;code&gt;concatAll . fmap concatAll&lt;&#x2F;code&gt; are the same polymorphic function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; [[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;b&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;d&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;e&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]] &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abcde&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; fmap concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; [[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;b&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;d&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;e&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]] &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abcde&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Both &lt;code&gt;concatAll . singleton&lt;&#x2F;code&gt; and &lt;code&gt;concatAll . fmap singleton&lt;&#x2F;code&gt; are the identity function on lists:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; singleton &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abcde&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abcde&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; concatAll &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; fmap singleton &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abcde&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;quot;abcde&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;why-monads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-monads&quot; aria-label=&quot;Anchor link for: why-monads&quot;&gt;Why Monads?&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Monads give rise to a consequence that is incredibly powerful in programming. Recall from Definition 17 that  $(M, \mu, \epsilon)$ is a monad if and only if for all $X$,&lt;&#x2F;p&gt;
&lt;p&gt;(M1) $\mu_X \circ \mu_{M(X)} = \mu_X \circ M(\mu_X)$, and&lt;&#x2F;p&gt;
&lt;p&gt;(M2) $\mu_X \circ \epsilon_{M(X)} = \mu_X \circ M(\epsilon_{X}) = 1_{M(X)}$.&lt;&#x2F;p&gt;
&lt;p&gt;Further recall what it means for $\mu$ and $\epsilon$ to be natural, i.e. for all objects $A$, $B$ and morphisms $f: A \to B$, $\mu_B \circ M(M(f)) = M(f) \circ \mu_A$ and $M(f) \circ \epsilon_A = \epsilon_B \circ f$.&lt;&#x2F;p&gt;
&lt;p&gt;Now, given monad $(M, \mu, \epsilon)$, and morphisms $f: A \to M(B)$ and $g: B \to M(C)$, let us define a new binary operation $\oplus$ called &lt;strong&gt;Kleisli composition&lt;&#x2F;strong&gt; where&lt;br &#x2F;&gt;
$g \oplus f: A \to M(C)$, is given by&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#7&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;$$
g \oplus f = \mu_{C} \circ M(g) \circ f
$$&lt;&#x2F;p&gt;
&lt;p&gt;Let us now show a correspondence between our earlier definition of monads and $\oplus$. First, an incredibly elementary lemma:&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Lemma 7.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have parallel morphisms $g, h: A \to B$. $g = h$ if and only if for all morphisms $f: Z \to A$, $g\circ f = h \circ f$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. From left to right, if $g = h$ then for all $f$, $g\circ f = h\circ f$. This is simple to show by subtituting $g$ with $h$, giving us $h \circ f = h\circ f$. From right to left, since for all $f$ we have $g \circ f = h \circ f$, then we have $g \circ 1_B = h \circ 1_B$. By the property of the identity morphism we get $g = h$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Theorem 8.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Fix category $\mathcal{C}$. $(M,\mu,\epsilon)$ is a monad if and only if:&lt;&#x2F;p&gt;
&lt;p&gt;(A1) For all $f: A \to M(B)$, $g: B \to M(C)$ and $h: C \to M(D)$, $\oplus$ is associative, i.e. $(h\oplus g)\oplus f = h \oplus (g \oplus f)$.&lt;&#x2F;p&gt;
&lt;p&gt;(A2) For all $f: A \to M(B)$: $\epsilon$ is unital, i.e. $f \oplus \epsilon_A = \epsilon_{M(B)} \oplus f = f$.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. First we show that conditions A1 and M1 are equivalent.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;&amp;amp; (h\oplus g)\oplus f &amp;amp;= h \oplus (g \oplus f) &amp;amp;&amp;amp; \tag{A1}\\
\Leftrightarrow&amp;amp;&amp;amp; \mu_D \circ M(h \oplus g) \circ f &amp;amp;= \mu_D \circ M(h) \circ (g \oplus f) &amp;amp;&amp;amp; \triangleright \text{ expansion on }\oplus\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_d \circ M(\mu_D \circ M(h) \circ g) \circ f &amp;amp;= \mu_D \circ M(h) \circ \mu_C \circ M(g) \circ f &amp;amp;&amp;amp; \triangleright \text{ expansion on }\oplus\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_D \circ M(\mu_D) \circ M(M(h)) \circ M(g)&amp;amp;= \mu_D \circ M(h) \circ \mu_C \circ M(g) &amp;amp;&amp;amp; \triangleright \text{ functoriality of }M\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_D \circ M(\mu_D) \circ M(M(h))&amp;amp;= \mu_D \circ \mu_{M(D)} \circ M(M(h))&amp;amp;&amp;amp; \triangleright \text{ naturality of }\mu\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_D \circ M(\mu_D) &amp;amp;= \mu_D \circ \mu_{M(D)} &amp;amp;&amp;amp; \tag{M1}
\end{align}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Now, let us show that conditions A2 and M2 are equivalent.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;&amp;amp; f \oplus \epsilon_A &amp;amp;= \epsilon_{M(B)} \oplus f &amp;amp;&amp;amp;= f &amp;amp;&amp;amp; \tag{A2}\\
\Leftrightarrow &amp;amp;&amp;amp; f \oplus \epsilon_A &amp;amp;= \epsilon_{M(B)} \oplus f &amp;amp;&amp;amp;= 1_{M(B)} \circ f &amp;amp;&amp;amp; \triangleright\text{ identity morphism}\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_B \circ M(f) \circ \epsilon_A &amp;amp;= \mu_B \circ M(\epsilon_B) \circ f &amp;amp;&amp;amp;= 1_{M(B)} \circ f &amp;amp;&amp;amp; \triangleright\text{ expansion on }\oplus\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_B \circ \epsilon_{M(B)} \circ f &amp;amp;= \mu_B \circ M(\epsilon_B) \circ f &amp;amp;&amp;amp;= 1_{M(B)} \circ f &amp;amp;&amp;amp; \triangleright\text{ naturality of }\epsilon\notag\\
\Leftrightarrow &amp;amp;&amp;amp; \mu_B \circ \epsilon_{M(B)}&amp;amp;= \mu_B \circ M(\epsilon_B) &amp;amp;&amp;amp;= 1_{M(B)} &amp;amp;&amp;amp; \tag{M2}
\end{align}
$$&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Let us call morphisms $f: A \to M(B)$ as monadic morphisms. Theorem 8 shows us that a monad allows us to compose monadic morphisms via Kleisli composition associatively and unitally, and conversely, any definition of natural transformations $\mu$ and $\epsilon$ together with functor $M$ that gives associativity and unity of Kleisli composition of monadic morphisms is a monad. This is precisely the motivation behind the &lt;code&gt;Monad&lt;&#x2F;code&gt; typeclass in Haskell.&lt;&#x2F;p&gt;
&lt;p&gt;Let us attempt to define our own monad typeclass in Haskell, where &lt;code&gt;return&#x27;&lt;&#x2F;code&gt; is $\epsilon$ and &lt;code&gt;join&#x27;&lt;&#x2F;code&gt; is $\mu$:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#55b4d4;&quot;&gt;Functor &lt;&#x2F;span&gt;&lt;span&gt;m =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#55b4d4;&quot;&gt;Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;return&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;m (m a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, let us define Kleisli composition for all monads in Haskell:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(&amp;lt;=&amp;lt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m c
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; fmap g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; f
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As an example, let us create the list monad (where &lt;code&gt;return&#x27;&lt;&#x2F;code&gt; is the same as &lt;code&gt;singleton&lt;&#x2F;code&gt; and &lt;code&gt;join&#x27;&lt;&#x2F;code&gt; is the same as &lt;code&gt;concatAll&lt;&#x2F;code&gt; from Example 15), and two list-producing functions&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- List monad
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; [] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    return&amp;#39; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;    join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;    join&amp;#39; (x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; xs) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt; join&amp;#39; xs
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- List-producing functions
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: String -&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;f x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [length x * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Num &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;g x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61676ccc;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#86b300;&quot;&gt;&amp;quot;abc&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- [7,8,9]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;connections-to-monads-in-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#connections-to-monads-in-programming&quot; aria-label=&quot;Anchor link for: connections-to-monads-in-programming&quot;&gt;Connections to Monads in Programming&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;However, in programming, our example earlier may be somewhat awkward. Let us look at another example. In many other languages, the &lt;code&gt;Option&lt;&#x2F;code&gt; type constructor represents an optional value, i.e. &lt;code&gt;Option a&lt;&#x2F;code&gt; is either &lt;code&gt;Some a&lt;&#x2F;code&gt; or it is nothing, i.e. &lt;code&gt;None&lt;&#x2F;code&gt;. Clearly, this &lt;code&gt;Option&lt;&#x2F;code&gt; type is also a functor. Let us also make &lt;code&gt;Option&lt;&#x2F;code&gt; a monad, so that we can compose functions that return optional values:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- The Option monad
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;deriving &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Show
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Functor Option where
&lt;&#x2F;span&gt;&lt;span&gt;    fmap f (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; x) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f x
&lt;&#x2F;span&gt;&lt;span&gt;    fmap f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;Option where
&lt;&#x2F;span&gt;&lt;span&gt;    return&amp;#39; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;    join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;    join&amp;#39; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; a)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;    join&amp;#39; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some None&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- A divide function that does not divide by 0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Int -&amp;gt; Int -&amp;gt; Option Int
&lt;&#x2F;span&gt;&lt;span&gt;divideBy a b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;of
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;    x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;`div`&lt;&#x2F;span&gt;&lt;span&gt; x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;24 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Some 2
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;24 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;24 &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What we would really like to have is a way to express sequential Kleisli composition, i.e. instead of &lt;code&gt;h &amp;lt;=&amp;lt; g &amp;lt;=&amp;lt; f $ x&lt;&#x2F;code&gt;, we could write something like &lt;code&gt;f x &amp;gt;&amp;gt;=&amp;gt;&amp;gt; g &amp;gt;&amp;gt;=&amp;gt;&amp;gt; h&lt;&#x2F;code&gt; which means &quot;first do &lt;code&gt;f x&lt;&#x2F;code&gt;, then monadically apply &lt;code&gt;g&lt;&#x2F;code&gt; to it, finally monadically apply &lt;code&gt;h&lt;&#x2F;code&gt; to that result&quot;. It is relatively simple to define &lt;code&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(&amp;gt;&amp;gt;=&amp;gt;&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b
&lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; fmap f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; x 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see from this definition that &lt;code&gt;g &amp;lt;=&amp;lt; f&lt;&#x2F;code&gt; is &lt;code&gt;\x -&amp;gt; f x &amp;gt;&amp;gt;=&amp;gt;&amp;gt; g&lt;&#x2F;code&gt;. This rather miniscule addition makes it syntactically convenient to compose monadic results via Kleisli composition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;h &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span&gt;z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Some 2
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In fact, if we provide a definition of &lt;code&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;code&gt; for each monad, they do not need to also define &lt;code&gt;join&#x27;&lt;&#x2F;code&gt; since we can define &lt;code&gt;join&#x27;&lt;&#x2F;code&gt; based on &lt;code&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;code&gt; for any monad:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;join&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Monad&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m (m a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt;join&amp;#39; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; id
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What we have done was the re-construct the &lt;code&gt;Monad&lt;&#x2F;code&gt; typeclass and &lt;code&gt;Maybe&lt;&#x2F;code&gt; and &lt;code&gt;[]&lt;&#x2F;code&gt; monads in Haskell.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#fafafa;color:#61676c;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Monad typeclass (built-in in Haskell)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#55b4d4;&quot;&gt;Functor &lt;&#x2F;span&gt;&lt;span&gt;m =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#55b4d4;&quot;&gt;Monad &lt;&#x2F;span&gt;&lt;span&gt;m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(&amp;gt;&amp;gt;=) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: &lt;&#x2F;span&gt;&lt;span&gt;m a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- &amp;gt;&amp;gt;=&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- List monad (built-in in Haskell)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Monad&lt;&#x2F;span&gt;&lt;span&gt; [] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    return a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; [a]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;    (x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; xs) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; f x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt; (xs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; f)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Maybe (Option) monad (built-in in Haskell)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Maybe&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Some a
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- None
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;instance Monad Maybe where
&lt;&#x2F;span&gt;&lt;span&gt;    return a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Some&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; f x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- join function for all monads
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;join &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Monad &lt;&#x2F;span&gt;&lt;span&gt;m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m (m a) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt;join x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; id
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- kleisli composition
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;(&amp;lt;=&amp;lt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Monad &lt;&#x2F;span&gt;&lt;span&gt;m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; (a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m b) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;m c
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;lt;=&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; join &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; fmap g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt; f
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- A divide function that does not divide by 0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: Int -&amp;gt; Int -&amp;gt; Maybe Int
&lt;&#x2F;span&gt;&lt;span&gt;divideBy a b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;of
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;span&gt;    x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;`div`&lt;&#x2F;span&gt;&lt;span&gt; x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;h &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span&gt;z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; divideBy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29718;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ed9366;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fa6e32;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Just 2
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Nothing
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Nothing
&lt;&#x2F;span&gt;&lt;span&gt;    print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; z &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff8f40;&quot;&gt;48 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ed9366;&quot;&gt;&amp;gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; h &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#abb0b6;&quot;&gt;-- Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally, a natural question to ask would be, how do we know that our list and maybe monads are actually monads? As per Theorem 8, we can show that these are monads by showing associativity and unity of Kleisli composition. However, other programming texts usually give a different set of laws expressed in terms of &lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;. These laws are typically written as the &lt;strong&gt;monad laws&lt;&#x2F;strong&gt; for all &lt;code&gt;x&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;(H1) &lt;code&gt;return x &amp;gt;&amp;gt;= f ==== f x&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(H2) &lt;code&gt;f x &amp;gt;&amp;gt;= return ==== f x&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(H3) &lt;code&gt;f x &amp;gt;&amp;gt;= (\y -&amp;gt; (g y &amp;gt;&amp;gt;= h)) ==== (f x &amp;gt;&amp;gt;= g) &amp;gt;&amp;gt;= h&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We shall show this to be equivalent to conditions A1 and A2 (and by extension, M1 and M2) shown in Theorem 8.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Corollary 9.&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;An endofunctor (along with natural transformations $\epsilon$ and $\mu$ defined in the obvious way) has associative and unital Kleisli composition if and only if it satisfies the monad laws.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;strong&gt;Proof&lt;&#x2F;strong&gt;. Let us first show that condition A1 in Theorem 8 is met if and only if H3 is met:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#61676c;&quot;&gt;&lt;code&gt;&lt;span&gt;               (h &amp;lt;=&amp;lt; g) &amp;lt;=&amp;lt; f ==== h &amp;lt;=&amp;lt; (g &amp;lt;=&amp;lt; f)
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;=&amp;gt;        ((h &amp;lt;=&amp;lt; g) &amp;lt;=&amp;lt; f) x ==== (h &amp;lt;=&amp;lt; (g &amp;lt;=&amp;lt; f)) x
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;=&amp;gt;          f x &amp;gt;&amp;gt;= (h &amp;lt;=&amp;lt; g) ==== (g &amp;lt;=&amp;lt; f) x &amp;gt;&amp;gt;= h
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;=&amp;gt;  f x &amp;gt;&amp;gt;= (\y -&amp;gt; g y &amp;gt;&amp;gt;= h) ==== (f x &amp;gt;&amp;gt;= g) &amp;gt;&amp;gt;= h
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally we show that condition A2 in Theorem 8 is met if and only both H1 and H2 are met.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#61676c;&quot;&gt;&lt;code&gt;&lt;span&gt;      (f &amp;lt;=&amp;lt; return) ==== (return &amp;lt;=&amp;lt; f) ==== f
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;=&amp;gt; (f &amp;lt;=&amp;lt; return) x ==== (return &amp;lt;=&amp;lt; f) x ==== f x 
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;=&amp;gt;   return x &amp;gt;&amp;gt;= f ==== f x &amp;gt;&amp;gt;= return ==== f x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;Conclusion&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;We have shown, through immense suffering, that we can construct a category of types $\mathcal{T}$ with morphisms and functions between these types. From this, we have also shown.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a functor (in the programming sense) is precisely an endofunctor on $\mathcal{T}$;&lt;&#x2F;li&gt;
&lt;li&gt;product and function types (in the programming sense) are precisely product and exponential objects in $\mathcal{T}$;&lt;&#x2F;li&gt;
&lt;li&gt;a polymorphic function (in the programming sense) is precisely a natural transformation between two parallel endofunctors on $\mathcal{T}$;&lt;&#x2F;li&gt;
&lt;li&gt;a monoid (in the programming sense) is precisely a monoid in the monoidal category $\mathcal{T}$ induced by the cartesian product and the unit type;&lt;&#x2F;li&gt;
&lt;li&gt;a monad (in the programming sense) is precisely a monad on $\mathcal{T}$, which is a monoid in the category of endofunctors of $\mathcal{T}$, which we know is a strict monoidal category, induced by functor composition and the identity functor;&lt;&#x2F;li&gt;
&lt;li&gt;if in defining a monad (in the programming sense) we satisfy the three monad laws (in the programming sense), what we have is actually a monad on $\mathcal{T}$;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Your reward for finishing this document? Bragging rights.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;appuniversalproperty&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#appuniversalproperty&quot; aria-label=&quot;Anchor link for: appuniversalproperty&quot;&gt;Universal Properties, Formally&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 18 (Universal Morphism).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Let ${F:{\mathcal {C}}\rightarrow {\mathcal {D}}}$ be a functor between categories ${\mathcal {C}}$ and ${\mathcal {D}}$. Let $A$ and $U$ be objects of ${\mathcal {C}}$, and $X$ be an object of ${\mathcal {D}}$.&lt;&#x2F;p&gt;
&lt;p&gt;Then, a &lt;strong&gt;universal morphism&lt;&#x2F;strong&gt; from $F$ to $X$ is a unique pair $(U, u: F(U) \to X)$ that satisfies the following &lt;strong&gt;universal property&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;For any morphism $f: F(A) \rightarrow X$ in ${\mathcal {D}}$, there exists a unique morphism $h: A \to U$ in ${\mathcal {C}}$ such that the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJYIl0sWzEsMCwiRihVKSJdLFszLDAsIlUiXSxbMSwxLCJGKEEpIl0sWzMsMSwiQSJdLFsxLDAsInUiLDJdLFszLDAsImYiXSxbMywxLCJGKGgpIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzQsMiwiaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJYIl0sWzEsMCwiRihVKSJdLFszLDAsIlUiXSxbMSwxLCJGKEEpIl0sWzMsMSwiQSJdLFsxLDAsInUiLDJdLFszLDAsImYiXSxbMywxLCJGKGgpIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzQsMiwiaCIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==&amp;embed&quot; width=&quot;470&quot; height=&quot;224&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;We shall now re-define our characterization of the categorical product in Definition 3 as a universal property.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 3a (Product).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Let the functor $F: \mathcal{C} \to \mathcal{C} \times \mathcal{C}$ be a functor from the category $\mathcal{C}$ to its product category (defined in Definition 7), given as $F(X) = (X, X)$ on all objects $X$ and $F(f: A \to B) = (f, f)$ on all morphisms $f$. Then, $(A \times B, (\pi_1, \pi_2): F(A \times B) \to (A, B))$ is a universal morphism from $F$ to $(A, B)$ which characterizes the product $A \times B$. This means that for all objects $X$ in $\mathcal{C}$ and morphisms $f&#x27;: F(X) \to (A, B)$ in $\mathcal{C} \times \mathcal{C}$, there exists a unique morphism $p:X \to A \times B$ which makes the following diagram commute:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCIoQSwgQikiXSxbMSwwLCJGKEFcXHRpbWVzIEIpIl0sWzMsMCwiQVxcdGltZXMgQiJdLFsxLDEsIkYoWCkiXSxbMywxLCJYIl0sWzEsMCwieyhcXHBpXzEsXFxwaV8yKX0iLDJdLFszLDAsImYnIl0sWzMsMSwiRihwKSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsInAiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCIoQSwgQikiXSxbMSwwLCJGKEFcXHRpbWVzIEIpIl0sWzMsMCwiQVxcdGltZXMgQiJdLFsxLDEsIkYoWCkiXSxbMywxLCJYIl0sWzEsMCwieyhcXHBpXzEsXFxwaV8yKX0iLDJdLFszLDAsImYnIl0sWzMsMSwiRihwKSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsInAiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=&amp;embed&quot; width=&quot;581&quot; height=&quot;224&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Replacing $F(x)$ with $(x, x)$ everywhere and the morphism $f&#x27;: F(X) \to (A, B)$ with a pair of morphisms $(f: X \to A, g: X \to B)$ in the commutative diagram above gives us the following commutative diagram:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCIoQSwgQikiXSxbMSwwLCIoQVxcdGltZXMgQiwgQSBcXHRpbWVzIEIpIl0sWzMsMCwiQVxcdGltZXMgQiJdLFsxLDEsIihYLCBYKSJdLFszLDEsIlgiXSxbMSwwLCJ7KFxccGlfMSxcXHBpXzIpfSIsMl0sWzMsMCwieyhmLCBnKX0iXSxbMywxLCJ7KHAsIHApfSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsInAiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0= --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCIoQSwgQikiXSxbMSwwLCIoQVxcdGltZXMgQiwgQSBcXHRpbWVzIEIpIl0sWzMsMCwiQVxcdGltZXMgQiJdLFsxLDEsIihYLCBYKSJdLFszLDEsIlgiXSxbMSwwLCJ7KFxccGlfMSxcXHBpXzIpfSIsMl0sWzMsMCwieyhmLCBnKX0iXSxbMywxLCJ7KHAsIHApfSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs0LDIsInAiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=&amp;embed&quot; width=&quot;608&quot; height=&quot;224&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Destructuring the pairs in the triangle on the left we recover the commutative diagram in $\mathcal{C}$ given in Definition 3.&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;p&gt;Now we can also re-define our characterization of the exponential object in Definition 6 as a universal property.&lt;&#x2F;p&gt;
&lt;div class=&quot;note-container&quot;&gt;
  
    &lt;div class=&quot;note-header&quot;&gt;
      
        &lt;div class=&quot;note-icon&quot;&gt;
        &lt;p&gt;Definition 6a (Exponential Object).&lt;&#x2F;p&gt;

        &lt;&#x2F;div&gt;
      
    &lt;&#x2F;div&gt;
    &lt;div class=&quot;note-content&quot;&gt;
      &lt;p&gt;Suppose we have a category $\mathcal{C}$ with objects $B$ and $C$, and the category contains all binary products with $B$, i.e. for all objects $A$ in $\mathcal{C}$ then $A \times B$ is also in $\mathcal{C}$. We define the functor $F: \mathcal{C} \to \mathcal{C}$ given by $F(A) = A \times B$ for all objects $A$ in $\mathcal{C}$ and $F(f) = f \times 1_B$ for all morphisms $f$ in $\mathcal{C}$. Then, $(C^B, \epsilon: C^B \times B \to C)$ is a universal morphism from $F$ to $C$ which characterizes the exponential object $C^B$. This means that for all morphisms $f: F(A) \to C$ in $\mathcal{C}$, there exists a unique morphism $\lambda f: A \to C^B$ such that the following diagram commutes:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDIl0sWzEsMCwiRihDXkIpIl0sWzMsMCwiQ15CIl0sWzEsMSwiRihBKSJdLFszLDEsIkEiXSxbMSwwLCJ7XFxlcHNpbG9ufSIsMl0sWzMsMCwiZiJdLFszLDEsIkYoXFxsYW1iZGEgZikiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNCwyLCJcXGxhbWJkYSBmIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDIl0sWzEsMCwiRihDXkIpIl0sWzMsMCwiQ15CIl0sWzEsMSwiRihBKSJdLFszLDEsIkEiXSxbMSwwLCJ7XFxlcHNpbG9ufSIsMl0sWzMsMCwiZiJdLFszLDEsIkYoXFxsYW1iZGEgZikiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbNCwyLCJcXGxhbWJkYSBmIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d&amp;embed&quot; width=&quot;489&quot; height=&quot;234&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Replacing $F(A)$ with $A \times B$ for all objects $A$ and $F(f)$ with $f \times 1_B$ for all morphisms $f$ allows us to recover the original commutative diagram shown in Definition 6:&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; flex-direction:column;align-items:center;justify-content:center;&quot;&gt;
&lt;!-- https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDIl0sWzEsMCwiQ15CIFxcdGltZXMgQiJdLFszLDAsIkNeQiJdLFsxLDEsIkEgXFx0aW1lcyBCIl0sWzMsMSwiQSJdLFsxLDAsIntcXGVwc2lsb259IiwyXSxbMywwLCJmIl0sWzMsMSwie1xcbGFtYmRhIGYgXFx0aW1lcyAxX0J9IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzQsMiwiXFxsYW1iZGEgZiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ== --&gt;
&lt;iframe class=&quot;quiver-embed&quot; src=&quot;https:&#x2F;&#x2F;q.uiver.app&#x2F;#q=WzAsNSxbMCwwLCJDIl0sWzEsMCwiQ15CIFxcdGltZXMgQiJdLFszLDAsIkNeQiJdLFsxLDEsIkEgXFx0aW1lcyBCIl0sWzMsMSwiQSJdLFsxLDAsIntcXGVwc2lsb259IiwyXSxbMywwLCJmIl0sWzMsMSwie1xcbGFtYmRhIGYgXFx0aW1lcyAxX0J9IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzQsMiwiXFxsYW1iZGEgZiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==&amp;embed&quot; width=&quot;504&quot; height=&quot;234&quot; style=&quot;border-radius: 8px; border: none;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p style=&quot;font-size:0.8em&quot;&gt;&lt;em&gt;Click on quiver logo to view full diagram.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  
&lt;&#x2F;div&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;Footnotes&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Russell&#x27;s paradox shows us that we cannot have a set of all sets. Therefore, the collection of all objects in $\textbf{Set}$ is not a set. This makes $\textbf{Set}$ what is called a &lt;em&gt;large category&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Types and functions in Haskell do not actually assemble into a category due to $\bot$ and &lt;code&gt;seq&lt;&#x2F;code&gt;, but we shall temporarily ignore these and assume they do.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;The fact that diagrams are formally defined in category theory blows my mind. Even still, diagrams also assemble into categories!&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;By Russell&#x27;s paradox we cannot have a category of &lt;strong&gt;all&lt;&#x2F;strong&gt; categories—this is the &lt;strong&gt;quasicategory&lt;&#x2F;strong&gt; $\textbf{CAT}$. However, there does exist the category $\textbf{Cat}$, the category of all &lt;strong&gt;small&lt;&#x2F;strong&gt; categories, which are categories where the collection of its morphisms forms a set. $\textbf{Cat}$ is not an object of itself, because it is not small.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;In general, we cannot claim that $\alpha F \circ \alpha = F\alpha \circ \alpha$ implies $\alpha F = F\alpha$. This is only true when $\alpha$ is epic (the categorical equivalent of &lt;strong&gt;surjective&lt;&#x2F;strong&gt;).&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;6&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2F;sup&gt;
&lt;p&gt;Definition 14 should appear eerily similar to the definition of a category, shown in Definition 1. As such, we can quite easily model this set-theoretic monoid as a category: A &lt;strong&gt;monoid&lt;&#x2F;strong&gt; is a category with one object. To understand this characterization, allow $M$ to be the only object in a categorical monoid $\mathcal{C}$, and $\cdot$ be the composition of morphisms and $1_M$ be the identity. Then, we can see that this category fits the monoid axioms, i.e. $1_M\circ f = f \circ 1_M = f$ for all morphisms $f$ in $\mathcal{C}$, and $f \circ (g \circ h) = (f \circ g) \circ h$ for all morphisms $f, g, h$ in $\mathcal{C}$.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;7&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;7&lt;&#x2F;sup&gt;
&lt;p&gt;This is also composition in a Kleisli Category.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
</feed>
